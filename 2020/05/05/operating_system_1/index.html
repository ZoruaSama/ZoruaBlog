<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>操作系统 | 2. 进程管理 | Zorua's Blog</title><meta name="description" content="思维导图  进程管理  进程的基本概念  程序的顺序执行及其特征 前趋图 程序的并发执行及其特征  程序并发执行的条件   进程概念 进程的特征与状态  进程的特征 进程和程序的区别 进程的三种基本状态 挂起状态 转换   进程控制块  进程控制块中的信息  进程标识符 处理机状态 进程调度信息 进程控制信息   进程控制块的组织方式  链接方式 索引方式       进程控制  操作系统内核"><meta name="keywords" content="操作系统,OS"><meta name="author" content="Zorua"><meta name="copyright" content="Zorua"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="dns-prefetch" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="https://hm.baidu.com"/><link rel="dns-prefetch" href="https://hm.baidu.com"/><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin="crossorigin"/><link rel="dns-prefetch" href="https://fonts.googleapis.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="dns-prefetch" href="//busuanzi.ibruce.info"/><meta name="twitter:card" content="summary"><meta name="twitter:title" content="操作系统 | 2. 进程管理"><meta name="twitter:description" content="思维导图  进程管理  进程的基本概念  程序的顺序执行及其特征 前趋图 程序的并发执行及其特征  程序并发执行的条件   进程概念 进程的特征与状态  进程的特征 进程和程序的区别 进程的三种基本状态 挂起状态 转换   进程控制块  进程控制块中的信息  进程标识符 处理机状态 进程调度信息 进程控制信息   进程控制块的组织方式  链接方式 索引方式       进程控制  操作系统内核"><meta name="twitter:image" content="https://gitee.com/zoruasama/Zorua-Pic/raw/master/20200429125019.png"><meta property="og:type" content="article"><meta property="og:title" content="操作系统 | 2. 进程管理"><meta property="og:url" content="https://zoruasama.gitee.io/2020/05/05/operating_system_1/"><meta property="og:site_name" content="Zorua's Blog"><meta property="og:description" content="思维导图  进程管理  进程的基本概念  程序的顺序执行及其特征 前趋图 程序的并发执行及其特征  程序并发执行的条件   进程概念 进程的特征与状态  进程的特征 进程和程序的区别 进程的三种基本状态 挂起状态 转换   进程控制块  进程控制块中的信息  进程标识符 处理机状态 进程调度信息 进程控制信息   进程控制块的组织方式  链接方式 索引方式       进程控制  操作系统内核"><meta property="og:image" content="https://gitee.com/zoruasama/Zorua-Pic/raw/master/20200429125019.png"><meta property="article:published_time" content="2020-05-05T14:55:00.000Z"><meta property="article:modified_time" content="2020-05-24T05:29:32.709Z"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>var autoChangeMode = 'false'
var t = Cookies.get("theme")
if (autoChangeMode == '1'){
  var isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
  var isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
  var isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined){
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport){
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour < 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
  }
  } else if (t == 'light') activateLightMode()
  else activateDarkMode()

} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css"><link rel="canonical" href="https://zoruasama.gitee.io/2020/05/05/operating_system_1/"><link rel="prev" title="数据库原理 | 3. 关系数据库标准语言SQL" href="https://zoruasama.gitee.io/2020/05/12/database_2/"><link rel="next" title="计算机网络 | 3. 数据链路层" href="https://zoruasama.gitee.io/2020/05/02/network_2/"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?46932657b6919c7a90436ce852f93565";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://zoruasama.gitee/io/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: {"bookmark":{"message_prev":"按","message_next":"键将本页加入书签"},"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#777777","bgDark":"#2d3035","position":"bottom-left"},
  baiduPush: true,
  highlightCopy: true,
  highlightLang: true,
  highlightShrink: 'false',
  isFontAwesomeV5: true,
  isPhotoFigcaption: false,
  islazyload: true,
  isanchor: false
  
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isSidebar: true  
  }</script><noscript><style>
#page-header {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><link rel="stylesheet" href="/css/custom.css"><link rel="stylesheet" href="/css/note.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/sviptzk/HexoStaticFile@master/Hexo/css/iconfont.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/sviptzk/HexoStaticFile@master/Hexo/css/hideCategory.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/sviptzk/HexoStaticFile@master/Hexo/css/buttons.min.css"><meta name="generator" content="Hexo 4.2.0"><link rel="alternate" href="/atom.xml" title="Zorua's Blog" type="application/atom+xml">
</head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/zorua.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">24</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">17</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">7</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/board/"><i class="fa-fw fa fa-comments"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> 列表</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> 电影</span></a></li></ul></div></div></div></div><i class="fa fa-arrow-right on" id="toggle-sidebar" aria-hidden="true">     </i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#思维导图"><span class="toc-number">1.</span> <span class="toc-text"> 思维导图</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#进程的基本概念"><span class="toc-number">2.</span> <span class="toc-text"> 进程的基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#程序的顺序执行及其特征"><span class="toc-number">2.1.</span> <span class="toc-text"> 程序的顺序执行及其特征</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#前趋图"><span class="toc-number">2.2.</span> <span class="toc-text"> 前趋图</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#程序的并发执行及其特征"><span class="toc-number">2.3.</span> <span class="toc-text"> 程序的并发执行及其特征</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#程序并发执行的条件"><span class="toc-number">2.3.1.</span> <span class="toc-text"> 程序并发执行的条件</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#进程概念"><span class="toc-number">2.4.</span> <span class="toc-text"> 进程概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#进程的特征与状态"><span class="toc-number">2.5.</span> <span class="toc-text"> 进程的特征与状态</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#进程的特征"><span class="toc-number">2.5.1.</span> <span class="toc-text"> 进程的特征</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#进程和程序的区别"><span class="toc-number">2.5.2.</span> <span class="toc-text"> 进程和程序的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#进程的三种基本状态"><span class="toc-number">2.5.3.</span> <span class="toc-text"> 进程的三种基本状态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#挂起状态"><span class="toc-number">2.5.4.</span> <span class="toc-text"> 挂起状态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#转换"><span class="toc-number">2.5.5.</span> <span class="toc-text"> 转换</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#进程控制块"><span class="toc-number">2.6.</span> <span class="toc-text"> 进程控制块</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#进程控制块中的信息"><span class="toc-number">2.6.1.</span> <span class="toc-text"> 进程控制块中的信息</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#进程标识符"><span class="toc-number">2.6.1.1.</span> <span class="toc-text"> 进程标识符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#处理机状态"><span class="toc-number">2.6.1.2.</span> <span class="toc-text"> 处理机状态</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#进程调度信息"><span class="toc-number">2.6.1.3.</span> <span class="toc-text"> 进程调度信息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#进程控制信息"><span class="toc-number">2.6.1.4.</span> <span class="toc-text"> 进程控制信息</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#进程控制块的组织方式"><span class="toc-number">2.6.2.</span> <span class="toc-text"> 进程控制块的组织方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#链接方式"><span class="toc-number">2.6.2.1.</span> <span class="toc-text"> 链接方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#索引方式"><span class="toc-number">2.6.2.2.</span> <span class="toc-text"> 索引方式</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#进程控制"><span class="toc-number">3.</span> <span class="toc-text"> 进程控制</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#操作系统内核"><span class="toc-number">3.1.</span> <span class="toc-text"> 操作系统内核</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#支撑功能"><span class="toc-number">3.1.1.</span> <span class="toc-text"> 支撑功能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#资源管理功能"><span class="toc-number">3.1.2.</span> <span class="toc-text"> 资源管理功能</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#进程的创建"><span class="toc-number">3.2.</span> <span class="toc-text"> 进程的创建</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#引起创建进程的事件"><span class="toc-number">3.2.1.</span> <span class="toc-text"> 引起创建进程的事件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#创建流程"><span class="toc-number">3.2.2.</span> <span class="toc-text"> 创建流程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#进程的终止"><span class="toc-number">3.3.</span> <span class="toc-text"> 进程的终止</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#正常结束"><span class="toc-number">3.3.1.</span> <span class="toc-text"> 正常结束</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#异常结束"><span class="toc-number">3.3.2.</span> <span class="toc-text"> 异常结束</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#外界干预"><span class="toc-number">3.3.3.</span> <span class="toc-text"> 外界干预</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#进程的终止过程"><span class="toc-number">3.3.4.</span> <span class="toc-text"> 进程的终止过程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#进程的阻塞与唤醒"><span class="toc-number">3.4.</span> <span class="toc-text"> 进程的阻塞与唤醒</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#引起进程阻塞和唤醒的事件"><span class="toc-number">3.4.1.</span> <span class="toc-text"> 引起进程阻塞和唤醒的事件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#进程阻塞过程"><span class="toc-number">3.4.2.</span> <span class="toc-text"> 进程阻塞过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#进程唤醒过程"><span class="toc-number">3.4.3.</span> <span class="toc-text"> 进程唤醒过程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#进程的挂起与激活"><span class="toc-number">3.5.</span> <span class="toc-text"> 进程的挂起与激活</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#进程的挂起"><span class="toc-number">3.5.1.</span> <span class="toc-text"> 进程的挂起</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#挂起原语的执行过程"><span class="toc-number">3.5.1.1.</span> <span class="toc-text"> 挂起原语的执行过程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#进程的激活"><span class="toc-number">3.5.2.</span> <span class="toc-text"> 进程的激活</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#激活原语执行过程"><span class="toc-number">3.5.2.1.</span> <span class="toc-text"> 激活原语执行过程</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#进程同步"><span class="toc-number">4.</span> <span class="toc-text"> 进程同步</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#进程同步的基本概念"><span class="toc-number">4.1.</span> <span class="toc-text"> 进程同步的基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#进程同步的原因"><span class="toc-number">4.1.1.</span> <span class="toc-text"> 进程同步的原因</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#临界资源critical-resouce"><span class="toc-number">4.1.2.</span> <span class="toc-text"> 临界资源(Critical Resouce)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#生产者-消费者producer-consumer问题"><span class="toc-number">4.1.2.1.</span> <span class="toc-text"> 生产者-消费者(producer-consumer)问题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#临界区critical-section"><span class="toc-number">4.1.3.</span> <span class="toc-text"> 临界区（critical section）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#同步机制应遵循的规则"><span class="toc-number">4.1.4.</span> <span class="toc-text"> 同步机制应遵循的规则</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#信号量机制"><span class="toc-number">4.2.</span> <span class="toc-text"> 信号量机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#整型信号量"><span class="toc-number">4.2.1.</span> <span class="toc-text"> 整型信号量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#记录型信号量"><span class="toc-number">4.2.2.</span> <span class="toc-text"> 记录型信号量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#and型信号量"><span class="toc-number">4.2.3.</span> <span class="toc-text"> AND型信号量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#信号量集"><span class="toc-number">4.2.4.</span> <span class="toc-text"> 信号量集</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#信号量的应用"><span class="toc-number">4.3.</span> <span class="toc-text"> 信号量的应用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#实现进程互斥"><span class="toc-number">4.3.1.</span> <span class="toc-text"> 实现进程互斥</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#实现前趋关系"><span class="toc-number">4.3.2.</span> <span class="toc-text"> 实现前趋关系</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#经典进程的同步问题"><span class="toc-number">5.</span> <span class="toc-text"> 经典进程的同步问题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#生产者消费者问题"><span class="toc-number">5.1.</span> <span class="toc-text"> 生产者—消费者问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#利用and信号量解决生产者消费者问题"><span class="toc-number">5.1.1.</span> <span class="toc-text"> 利用AND信号量解决生产者—消费者问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#哲学家进餐问题"><span class="toc-number">5.2.</span> <span class="toc-text"> 哲学家进餐问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#读者写者问题"><span class="toc-number">5.3.</span> <span class="toc-text"> 读者—写者问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#利用信号量集机制解决读者-写者问题"><span class="toc-number">5.3.1.</span> <span class="toc-text"> 利用信号量集机制解决读者-写者问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#独木桥问题"><span class="toc-number">5.4.</span> <span class="toc-text"> 独木桥问题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#管程机制"><span class="toc-number">6.</span> <span class="toc-text"> 管程机制</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#管程的引入"><span class="toc-number">6.1.</span> <span class="toc-text"> 管程的引入</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#管程的基本概念"><span class="toc-number">6.2.</span> <span class="toc-text"> 管程的基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#管程的语法"><span class="toc-number">6.2.1.</span> <span class="toc-text"> 管程的语法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#条件变量"><span class="toc-number">6.2.1.1.</span> <span class="toc-text"> 条件变量</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#利用管程解决生产者消费者问题"><span class="toc-number">6.3.</span> <span class="toc-text"> 利用管程解决生产者—消费者问题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#进程通信"><span class="toc-number">7.</span> <span class="toc-text"> 进程通信</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#进程通信的类型"><span class="toc-number">7.1.</span> <span class="toc-text"> 进程通信的类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#共享存储器系统shared-memory-system"><span class="toc-number">7.1.1.</span> <span class="toc-text"> 共享存储器系统(Shared-Memory System)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#消息传递系统message-passing-system"><span class="toc-number">7.1.2.</span> <span class="toc-text"> 消息传递系统(Message passing system)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#管道pipe通信共享文件方式"><span class="toc-number">7.1.3.</span> <span class="toc-text"> 管道(Pipe)通信（共享文件方式）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#消息传递通信的实现方法"><span class="toc-number">7.2.</span> <span class="toc-text"> 消息传递通信的实现方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#直接通信方式"><span class="toc-number">7.2.1.</span> <span class="toc-text"> 直接通信方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#间接通信方式"><span class="toc-number">7.2.2.</span> <span class="toc-text"> 间接通信方式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#消息传递系统实现中的若干问题"><span class="toc-number">7.3.</span> <span class="toc-text"> 消息传递系统实现中的若干问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#通信链路communication-link"><span class="toc-number">7.3.1.</span> <span class="toc-text"> 通信链路(communication link)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#消息的格式"><span class="toc-number">7.3.2.</span> <span class="toc-text"> 消息的格式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#进程同步方式"><span class="toc-number">7.3.3.</span> <span class="toc-text"> 进程同步方式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#消息缓冲队列通信机制"><span class="toc-number">7.4.</span> <span class="toc-text"> 消息缓冲队列通信机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#发送原语"><span class="toc-number">7.4.1.</span> <span class="toc-text"> 发送原语</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#线程"><span class="toc-number">8.</span> <span class="toc-text"> 线程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#线程的基本概念"><span class="toc-number">8.1.</span> <span class="toc-text"> 线程的基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#进程的两个基本属性"><span class="toc-number">8.1.1.</span> <span class="toc-text"> 进程的两个基本属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#线程的引入"><span class="toc-number">8.1.2.</span> <span class="toc-text"> 线程的引入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#线程-2"><span class="toc-number">8.1.3.</span> <span class="toc-text"> 线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#线程的属性"><span class="toc-number">8.1.4.</span> <span class="toc-text"> 线程的属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#线程的状态"><span class="toc-number">8.1.5.</span> <span class="toc-text"> 线程的状态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#线程的创建和终止"><span class="toc-number">8.1.6.</span> <span class="toc-text"> 线程的创建和终止</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#多线程os中的进程"><span class="toc-number">8.1.7.</span> <span class="toc-text"> 多线程OS中的进程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#线程和进程的关系"><span class="toc-number">8.1.8.</span> <span class="toc-text"> 线程和进程的关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#引入线程的好处"><span class="toc-number">8.1.9.</span> <span class="toc-text"> 引入线程的好处</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#线程与进程的比较"><span class="toc-number">8.1.10.</span> <span class="toc-text"> 线程与进程的比较</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#线程间的同步和通信"><span class="toc-number">8.2.</span> <span class="toc-text"> 线程间的同步和通信</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#互斥锁mutex"><span class="toc-number">8.2.1.</span> <span class="toc-text"> 互斥锁(mutex)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#条件变量-2"><span class="toc-number">8.2.2.</span> <span class="toc-text"> 条件变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#信号量机制-2"><span class="toc-number">8.2.3.</span> <span class="toc-text"> 信号量机制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#私用信号量private-samephore"><span class="toc-number">8.2.3.1.</span> <span class="toc-text"> 私用信号量(private samephore)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#公用信号量public-semaphore"><span class="toc-number">8.2.3.2.</span> <span class="toc-text"> 公用信号量(public semaphore)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#内核支持线程和用户级线程"><span class="toc-number">8.3.</span> <span class="toc-text"> 内核支持线程和用户级线程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#内核支持线程kernel-support-threads"><span class="toc-number">8.3.1.</span> <span class="toc-text"> 内核支持线程(Kernel-Support Threads)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#核心级线程的优点和缺点"><span class="toc-number">8.3.1.1.</span> <span class="toc-text"> 核心级线程的优点和缺点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#用户级线程user-level-threads"><span class="toc-number">8.3.2.</span> <span class="toc-text"> 用户级线程(User-Level Threads)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#用户级线程的优点和缺点"><span class="toc-number">8.3.2.1.</span> <span class="toc-text"> 用户级线程的优点和缺点</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#线程控制"><span class="toc-number">8.4.</span> <span class="toc-text"> 线程控制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#内核支持线程的实现"><span class="toc-number">8.4.1.</span> <span class="toc-text"> 内核支持线程的实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#用户级线程的实现"><span class="toc-number">8.4.2.</span> <span class="toc-text"> 用户级线程的实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#运行时系统runtime-system"><span class="toc-number">8.4.2.1.</span> <span class="toc-text"> 运行时系统(Runtime System)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#内核控制线程"><span class="toc-number">8.4.2.2.</span> <span class="toc-text"> 内核控制线程</span></a></li></ol></li></ol></li></ol></li></ol></div></div></div><div id="body-wrap"><div class="post-bg" id="nav" style="background-image: url(https://gitee.com/zoruasama/Zorua-Pic/raw/master/20200429125104.png)"><div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">Zorua's Blog</a></span><span class="pull_right menus"><div id="search_button"><a class="site-page social-icon search"><i class="fa fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/board/"><i class="fa-fw fa fa-comments"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> 列表</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> 电影</span></a></li></ul></div></div><span class="toggle-menu close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span></span></div><div id="post-info"><div id="post-title"><div class="posttitle">操作系统 | 2. 进程管理</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="发表于 2020-05-05 22:55:00"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2020-05-05</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="更新于 2020-05-24 13:29:32"><i class="fa fa-history" aria-hidden="true"></i> 更新于 2020-05-24</span></time><span class="post-meta__categories"><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a></span></div><div class="meta-secondline"> <span class="post-meta-wordcount"><i class="post-meta__icon far fa-file-word" aria-hidden="true"></i><span>字数总计:</span><span class="word-count">21.7k</span><span class="post-meta__separator">|</span><i class="post-meta__icon far fa-clock" aria-hidden="true"></i><span>阅读时长: 68 分钟</span></span></div><div class="meta-thirdline"><span class="post-meta-pv-cv"><span class="post-meta__separator">|</span><i class="fa fa-eye post-meta__icon" aria-hidden="true"> </i><span>阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-commentcount"><span class="post-meta__separator">|</span><i class="post-meta__icon far fa-comments" aria-hidden="true"></i><span>评论数:</span><a href="/2020/05/05/operating_system_1/#post-comment" itemprop="discussionUrl"><span class="valine-comment-count comment-count" data-xid="/2020/05/05/operating_system_1/" itemprop="commentCount"></span></a></span></div></div></div></div><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><h1 id="思维导图"><a class="markdownIt-Anchor" href="#思维导图"></a> 思维导图</h1>
<blockquote class="pullquote mindmap mindmap-md"><ul>
<li>进程管理
<ul>
<li>进程的基本概念
<ul>
<li>程序的顺序执行及其特征</li>
<li>前趋图</li>
<li>程序的并发执行及其特征
<ul>
<li>程序并发执行的条件</li>
</ul>
</li>
<li>进程概念</li>
<li>进程的特征与状态
<ul>
<li>进程的特征</li>
<li>进程和程序的区别</li>
<li>进程的三种基本状态</li>
<li>挂起状态</li>
<li>转换</li>
</ul>
</li>
<li>进程控制块
<ul>
<li>进程控制块中的信息
<ul>
<li>进程标识符</li>
<li>处理机状态</li>
<li>进程调度信息</li>
<li>进程控制信息</li>
</ul>
</li>
<li>进程控制块的组织方式
<ul>
<li>链接方式</li>
<li>索引方式</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>进程控制
<ul>
<li>操作系统内核
<ul>
<li>支撑功能</li>
<li>资源管理功能</li>
</ul>
</li>
<li>进程的创建
<ul>
<li>引起创建进程的事件</li>
<li>创建流程</li>
</ul>
</li>
<li>进程的终止
<ul>
<li>正常结束</li>
<li>异常结束</li>
<li>外界干预</li>
<li>进程的终止过程</li>
</ul>
</li>
<li>进程的阻塞与唤醒
<ul>
<li>引起进程阻塞和唤醒的事件</li>
<li>进程阻塞过程</li>
<li>进程唤醒过程</li>
</ul>
</li>
<li>进程的挂起与激活
<ul>
<li>进程的挂起
<ul>
<li>挂起原语的执行过程</li>
</ul>
</li>
<li>进程的激活
<ul>
<li>激活原语执行过程</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>进程同步
<ul>
<li>进程同步的基本概念
<ul>
<li>进程同步的原因</li>
<li>临界资源(Critical Resouce)
<ul>
<li>生产者-消费者(producer-consumer)问题</li>
</ul>
</li>
<li>临界区（critical section）</li>
<li>同步机制应遵循的规则</li>
</ul>
</li>
<li>信号量机制
<ul>
<li>整型信号量</li>
<li>记录型信号量</li>
<li>AND型信号量</li>
<li>信号量集</li>
</ul>
</li>
<li>信号量的应用
<ul>
<li>实现进程互斥</li>
<li>实现前趋关系</li>
</ul>
</li>
</ul>
</li>
<li>经典进程的同步问题
<ul>
<li>生产者—消费者问题
<ul>
<li>利用AND信号量解决生产者—消费者问题</li>
</ul>
</li>
<li>哲学家进餐问题</li>
<li>读者—写者问题
<ul>
<li>利用信号量集机制解决读者-写者问题</li>
</ul>
</li>
<li>独木桥问题</li>
</ul>
</li>
<li>管程机制
<ul>
<li>管程的引入</li>
<li>管程的基本概念
<ul>
<li>管程的语法
<ul>
<li>条件变量</li>
</ul>
</li>
</ul>
</li>
<li>利用管程解决生产者—消费者问题</li>
</ul>
</li>
<li>进程通信
<ul>
<li>进程通信的类型
<ul>
<li>共享存储器系统(Shared-Memory System)</li>
<li>消息传递系统(Message passing system)</li>
<li>管道(Pipe)通信（共享文件方式）</li>
</ul>
</li>
<li>消息传递通信的实现方法
<ul>
<li>直接通信方式</li>
<li>间接通信方式</li>
</ul>
</li>
<li>消息传递系统实现中的若干问题
<ul>
<li>通信链路(communication link)</li>
<li>消息的格式</li>
<li>进程同步方式</li>
</ul>
</li>
<li>消息缓冲队列通信机制
<ul>
<li>发送原语</li>
</ul>
</li>
</ul>
</li>
<li>线程
<ul>
<li>线程的基本概念
<ul>
<li>进程的两个基本属性</li>
<li>线程的引入</li>
<li>线程</li>
<li>线程的属性</li>
<li>线程的状态</li>
<li>线程的创建和终止</li>
<li>多线程OS中的进程</li>
<li>线程和进程的关系</li>
<li>引入线程的好处</li>
<li>线程与进程的比较</li>
</ul>
</li>
<li>线程间的同步和通信
<ul>
<li>互斥锁(mutex)</li>
<li>条件变量</li>
<li>信号量机制
<ul>
<li>私用信号量(private samephore)</li>
<li>公用信号量(public semaphore)</li>
</ul>
</li>
</ul>
</li>
<li>内核支持线程和用户级线程
<ul>
<li>内核支持线程(Kernel-Support Threads)
<ul>
<li>核心级线程的优点和缺点</li>
</ul>
</li>
<li>用户级线程(User-Level Threads)
<ul>
<li>用户级线程的优点和缺点</li>
</ul>
</li>
</ul>
</li>
<li>线程控制
<ul>
<li>内核支持线程的实现</li>
<li>用户级线程的实现
<ul>
<li>运行时系统(Runtime System)</li>
<li>内核控制线程</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
<h1 id="进程的基本概念"><a class="markdownIt-Anchor" href="#进程的基本概念"></a> 进程的基本概念</h1>
<h2 id="程序的顺序执行及其特征"><a class="markdownIt-Anchor" href="#程序的顺序执行及其特征"></a> 程序的顺序执行及其特征</h2>
<p>是单道批处理系统的执行方式，也用于简单的单片机系统.</p>
<ul>
<li>顺序执行的特征
<ul>
<li>顺序性：按照程序结构所指定的次序（可能有分支或循环）</li>
<li>封闭性：独占全部资源，计算机的状态只由于该程序的控制逻辑所决定</li>
<li>可再现性：初始条件相同则结果相同。如：可通过空指令控制时间关系</li>
</ul>
</li>
<li>仅当前一操作(程序段)执行完后，才能执行后继操作。例如，在进行计算时，总须先输入用户的程序和数据，然后进行计算，最后才能打印计算结果。例如语句s1,s2,s3必须按顺序执行。</li>
</ul>
<figure class="highlight pascal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">S1:  a∶=x+y;</span><br><span class="line">S2:  b∶=a-<span class="number">5</span>;</span><br><span class="line">S3:  c∶=b+<span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://gitee.com/zoruasama/Zorua-Pic/raw/master/20200502170526.png" alt="" /></p>
<h2 id="前趋图"><a class="markdownIt-Anchor" href="#前趋图"></a> 前趋图</h2>
<ul>
<li>前趋图(Precedence Graph)是一个有向无循环图，记为DAG(Directed Acyclic Graph)，用于描述进程之间执行的前后关系。图中的每个结点可用于描述一个程序段或进程，乃至一条语句；结点间的有向边则用于表示两个结点之间存在的偏序(Partial Order)或前趋关系(Precedence Relation)“<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">→</span></span></span></span>”</li>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>→</mo><mo>=</mo><mo stretchy="false">{</mo><mo stretchy="false">(</mo><msub><mi>P</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>P</mi><mi>j</mi></msub><mo stretchy="false">)</mo><mi mathvariant="normal">∣</mi><msub><mi>P</mi><mi>i</mi></msub><mtext> </mtext><mi>m</mi><mi>u</mi><mi>s</mi><mi>t</mi><mtext> </mtext><mi>c</mi><mi>o</mi><mi>m</mi><mi>p</mi><mi>l</mi><mi>e</mi><mi>t</mi><mi>e</mi><mtext> </mtext><mi>b</mi><mi>e</mi><mi>f</mi><mi>o</mi><mi>r</mi><mi>e</mi><mtext> </mtext><msub><mi>P</mi><mi>j</mi></msub><mtext> </mtext><mi>m</mi><mi>a</mi><mi>y</mi><mtext> </mtext><mi>s</mi><mi>t</mi><mi>a</mi><mi>r</mi><mi>t</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\rightarrow = \{(P_i, P_j)|P_i\ must\  complete\  before\   P_j \  may \  start\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">→</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mopen">{</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mord">∣</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace"> </span><span class="mord mathdefault">m</span><span class="mord mathdefault">u</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mspace"> </span><span class="mord mathdefault">c</span><span class="mord mathdefault">o</span><span class="mord mathdefault">m</span><span class="mord mathdefault">p</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mord mathdefault">t</span><span class="mord mathdefault">e</span><span class="mspace"> </span><span class="mord mathdefault">b</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">e</span><span class="mspace"> </span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace"> </span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace"> </span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">t</span><span class="mclose">}</span></span></span></span>, 如果<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><msub><mi>P</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>P</mi><mi>j</mi></msub><mo stretchy="false">)</mo><mo>∈</mo><mo>→</mo></mrow><annotation encoding="application/x-tex">(P_i, P_j)\in \rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">→</span></span></span></span>,可写成<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mi>i</mi></msub><mo>→</mo><msub><mi>P</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">P_i \rightarrow P_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>，称<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">P_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">P_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>的直接前趋，而称<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">P_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">P_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>的直接后继。在前趋图中，把没有前趋的结点称为初始结点(Initial Node)，把没有后继的结点称为终止结点(Final Node)</li>
<li>每个结点还具有一个重量(Weight, <strong>权值</strong>)，用于表示该结点所含有的程序量或结点的执行时间</li>
</ul>
<p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://gitee.com/zoruasama/Zorua-Pic/raw/master/20200502171742.png" alt="" /></p>
<h2 id="程序的并发执行及其特征"><a class="markdownIt-Anchor" href="#程序的并发执行及其特征"></a> 程序的并发执行及其特征</h2>
<p>在现在的操作系统应用，具有许多新的特征。引入并发执行的目的是为了提高资源利用率。<br />
<img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://gitee.com/zoruasama/Zorua-Pic/raw/master/20200502171820.png" alt="并发执行时的前趋图" /></p>
<blockquote>
<ul>
<li>
<p>例如有两个循环程序A和B，它们共享一个变量N</p>
<ul>
<li><strong>A:</strong> N:=N+1;</li>
<li><strong>B:</strong> Print(N); N:=0;</li>
</ul>
</li>
<li>
<p>程序A和B以不同的速度运行(失去封闭性，导致不可再现性）</p>
</li>
<li>
<p>N∶=N+1在Print(N)和N∶=0之前，此时得到的N值分别为<strong>n+1, n+1, 0</strong></p>
</li>
<li>
<p>N∶=N+1在Print(N)和N∶=0之后，此时得到的N值分别为<strong>n, 0, 1</strong></p>
</li>
<li>
<p>N∶=N+1在Print(N)和N∶=0之间，此时得到的N值分别为<strong>n, n+1, 0</strong><br />
注意：A、B程序得到的共享变量结果不同，失去封闭性、不可再现性；要得到良好的控制，系统必须要进行管理——进程控制管理</p>
</li>
</ul>
</blockquote>
<ul>
<li>并发执行的特征
<ul>
<li>间断(异步)性
<ul>
<li>“走走停停”，一个程序可能走到中途停下来，失去原有的时序关系；</li>
</ul>
</li>
<li>失去封闭性
<ul>
<li>共享资源，受其他程序的控制逻辑的影响。如：一个程序写到存储器中的数据可能被另一个程序修改，失去原有的不变特征。</li>
</ul>
</li>
<li>失去可再现性
<ul>
<li>失去封闭性 -&gt; 失去可再现性；外界环境在程序的两次执行期间发生变化，失去原有的可重复特征</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="程序并发执行的条件"><a class="markdownIt-Anchor" href="#程序并发执行的条件"></a> 程序并发执行的条件</h3>
<ul>
<li>并发执行失去封闭性的原因是共享资源的影响，去掉这种影响就行了。1966年，由Bernstein给出并发执行的条件。（这里没有考虑执行速度的影响。）</li>
<li>程序 P(i) 针对<strong>共享变量的读集和写集</strong><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>R</mi><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">R(i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mclose">)</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>W</mi><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">W(i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mclose">)</span></span></span></span></li>
<li>条件：任意两个程序<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">P(i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mclose">)</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>j</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">P(j)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">)</span></span></span></span>，有：
<ul>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>R</mi><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo><mo>∩</mo><mi>W</mi><mo stretchy="false">(</mo><mi>j</mi><mo stretchy="false">)</mo><mo>=</mo><mi mathvariant="normal">∅</mi><mo separator="true">;</mo></mrow><annotation encoding="application/x-tex">R(i) \cap W(j)=\emptyset;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∩</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.94444em;vertical-align:-0.19444em;"></span><span class="mord">∅</span><span class="mpunct">;</span></span></span></span></li>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>W</mi><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo><mo>∩</mo><mi>R</mi><mo stretchy="false">(</mo><mi>j</mi><mo stretchy="false">)</mo><mo>=</mo><mi mathvariant="normal">∅</mi><mo separator="true">;</mo></mrow><annotation encoding="application/x-tex">W(i) \cap R(j)=\emptyset;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∩</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.94444em;vertical-align:-0.19444em;"></span><span class="mord">∅</span><span class="mpunct">;</span></span></span></span></li>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>W</mi><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo><mo>∩</mo><mi>W</mi><mo stretchy="false">(</mo><mi>j</mi><mo stretchy="false">)</mo><mo>=</mo><mi mathvariant="normal">∅</mi><mo separator="true">;</mo></mrow><annotation encoding="application/x-tex">W(i) \cap W(j)=\emptyset;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∩</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.94444em;vertical-align:-0.19444em;"></span><span class="mord">∅</span><span class="mpunct">;</span></span></span></span></li>
</ul>
</li>
<li>前两条保证一个程序的两次读之间数据不变化；最后一条保证写的结果不丢掉</li>
</ul>
<hr />
<p>若两个程序<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">P_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">P_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>满足下述条件，便能并发执行且有可再现性：<br />
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>R</mi><mo stretchy="false">(</mo><msub><mi>P</mi><mn>1</mn></msub><mo stretchy="false">)</mo><mo>∩</mo><mi>W</mi><mo stretchy="false">(</mo><msub><mi>P</mi><mn>2</mn></msub><mo stretchy="false">)</mo><mo>∪</mo><mi>R</mi><mo stretchy="false">(</mo><msub><mi>P</mi><mn>2</mn></msub><mo stretchy="false">)</mo><mo>∩</mo><mi>W</mi><mo stretchy="false">(</mo><msub><mi>P</mi><mn>1</mn></msub><mo stretchy="false">)</mo><mo>∪</mo><mi>W</mi><mo stretchy="false">(</mo><msub><mi>P</mi><mn>1</mn></msub><mo stretchy="false">)</mo><mo>∩</mo><mi>W</mi><mo stretchy="false">(</mo><msub><mi>P</mi><mn>2</mn></msub><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">{</mo><mtext> </mtext><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">R(P_1)\cap W(P_2) \cup R(P_2)\cap W(P_1) \cup W(P_1)\cap W(P_2)=\{\ \}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∩</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∪</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∩</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∪</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∩</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mspace"> </span><span class="mclose">}</span></span></span></span><br />
就是不能<code>同时写</code>和<code>一读一写</code>。</p>
<ul>
<li>“读集” <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>R</mi><mo stretchy="false">(</mo><msub><mi>P</mi><mi>i</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">R(P_i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> 为程序 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">P_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 在执行期间所需参考的所有变量的集合。</li>
<li>“写集” <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>W</mi><mo stretchy="false">(</mo><msub><mi>P</mi><mi>i</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">W(P_i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>为程序 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">P_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 在执行期间所需改变的所有变量的集合。</li>
</ul>
<h2 id="进程概念"><a class="markdownIt-Anchor" href="#进程概念"></a> 进程概念</h2>
<ul>
<li>进程（Process）
<ul>
<li>描述性定义：计算机中的所有程序（软件），按照某种顺序运行，这种运行的过程称之为进程。</li>
</ul>
</li>
<li>进程的核心思想
<ul>
<li>进程是某种类型的一个活动，它有程序、输入、输出和状态。在分时操作系统中，单个CPU被若干进程共享，它使用某种调度算法决定何时停止一个进程的运行，转而为其他进程提供服务。</li>
</ul>
</li>
</ul>
<p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://gitee.com/zoruasama/Zorua-Pic/raw/master/20200502175206.png" alt="" /></p>
<ul>
<li>较典型的进程定义有：
<ul>
<li>进程是程序的一次执行</li>
<li>进程是一个程序及其数据在处理机上顺序执行时所发生的活动</li>
<li>进程是程序在一个数据集合上运行的过程，它是系统进行资源分配和调度的一个独立单位</li>
</ul>
</li>
</ul>
<h2 id="进程的特征与状态"><a class="markdownIt-Anchor" href="#进程的特征与状态"></a> 进程的特征与状态</h2>
<h3 id="进程的特征"><a class="markdownIt-Anchor" href="#进程的特征"></a> 进程的特征</h3>
<ul>
<li><strong>动态性</strong>：进程具有<strong>动态的地址空间</strong>（数量和内容），地址空间上包括：
<ul>
<li><strong>代码</strong>（指令执行和CPU状态的改变）</li>
<li><strong>数据</strong>（变量的生成和赋值）</li>
<li>系统<strong>控制信息</strong>（进程控制块的建立和系统收回）</li>
</ul>
</li>
<li><strong>独立性</strong>：各进程的<strong>地址空间相互独立</strong>，除非采用进程间通信手段；</li>
<li><strong>并发性</strong>：多个<strong>进程实体</strong>同存于内存中，且能在一段时间内同时运行；引入进程实体的目的就是并发执行</li>
<li><strong>异步性</strong>：各进程按各自独立的、不可预知的速度向前推进</li>
<li><strong>结构性</strong>：<strong>程序段、数据段和PCB</strong>；程序文件中通常也划分了代码段和数据段，进程的创建与撤消就是PCB的创建与撤消</li>
</ul>
<p>通常的程序是不能并发执行的。应为之配置进程控制块，即PCB；<strong>而由程序段、相关的数据段和PCB三部分便构成了进程实体</strong>。在许多情况下所说的进程，实际上是指进程实体。所谓创建进程，实质上是创建进程实体中的PCB；而撤销进程，实质上是撤销进程的PCB。</p>
<p>在引入了进程实体的概念后，我们可以把传统OS中的进程定义为：“<strong>进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位</strong>”。</p>
<h3 id="进程和程序的区别"><a class="markdownIt-Anchor" href="#进程和程序的区别"></a> 进程和程序的区别</h3>
<ul>
<li><strong>进程是动态的，程序是静态的</strong>：程序是有序代码的集合；进程是程序的执行。通常进程不可在计算机之间迁移；而程序通常对应着文件、静态和可以复制</li>
<li><strong>进程是暂时的，程序的永久的</strong>：进程是一个状态变化的过程，程序可长久保存</li>
<li><strong>进程与程序的组成不同</strong>：进程的组成包括程序、数据和进程控制块（即进程状态信息）</li>
<li><strong>进程与程序的对应关系</strong>：通过多次执行，一个程序可对应多个进程；通过调用关系，一个进程可包括多个程序</li>
</ul>
<h3 id="进程的三种基本状态"><a class="markdownIt-Anchor" href="#进程的三种基本状态"></a> 进程的三种基本状态</h3>
<ul>
<li>就绪(Ready)状态
<ul>
<li>可运行，已获得除<strong>CPU</strong>外的所需资源，等待分配CPU</li>
<li>一个系统中多个处于就绪状态的进程排成<strong>就绪队列</strong></li>
</ul>
</li>
<li>执行(Running)状态
<ul>
<li>占用<strong>CPU运行</strong>；处于此状态的进程的数目&lt;=CPU的数目</li>
<li>没有其它进程可以执行时（如所有进程都在阻塞状态），通常会自动执行系统的idle进程（相当于空操作）</li>
</ul>
</li>
<li>阻塞(Blocked)状态
<ul>
<li>等待某种条件（如I/O操作或进程同步），在条件满足之前<strong>无法继续执行</strong>。该事件发生前即使把处理机分配给该进程，也无法运行</li>
<li>通常阻塞进程也排成一个<strong>阻塞队列</strong></li>
</ul>
</li>
</ul>
<p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://gitee.com/zoruasama/Zorua-Pic/raw/master/20200502181839.png" alt="" /></p>
<ul>
<li>创建状态
<ul>
<li>进程刚建立，还未进入就绪队列。</li>
</ul>
</li>
<li>终止状态
<ul>
<li>进程已（正常或异常）结束，已从就绪队列中移出，但尚未撤销。</li>
<li>暂留，以便其他进程收集该进程的有关信息。<br />
<img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://gitee.com/zoruasama/Zorua-Pic/raw/master/20200502182014.png" alt="" /></li>
</ul>
</li>
</ul>
<h3 id="挂起状态"><a class="markdownIt-Anchor" href="#挂起状态"></a> 挂起状态</h3>
<ul>
<li>这个问题的出现是由于进程优先级的引入，一些低优先级进程可能等待较长时间，从而被对换至外存。这样做的目的是：
<ul>
<li><strong>提高处理机效率</strong>：就绪进程表为空时，要提交新进程，以提高处理机效率；</li>
<li><strong>为运行进程提供足够内存</strong>：资源紧张时，暂停某些进程，如：CPU繁忙（或实时任务执行），内存紧张</li>
<li><strong>用于调试</strong>：在调试时，挂起<strong>被调试进程</strong>（从而对其地址空间进行读写）</li>
</ul>
</li>
<li>引起进程挂起的原因有以下几种
<ul>
<li><strong>终端用户的请求</strong>
<ul>
<li>当终端用户在自己的程序运行期间发现有可疑问题时，希望暂时将自己的程序静止下来</li>
</ul>
</li>
<li><strong>父进程请求</strong>
<ul>
<li>父进程需要考查和修改子进程</li>
</ul>
</li>
<li><strong>负荷调节的需要</strong>
<ul>
<li>在实时系统中为了调整工作负荷可将不重要的进程挂起</li>
</ul>
</li>
<li><strong>操作系统的需要</strong>
<ul>
<li>如检查运行中的资源使用情况</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr />
<ul>
<li>挂起（Suspend）：进程从内存转到外存
<ul>
<li><strong>就绪挂起</strong>：活动就绪到静止就绪，当有<strong>高优先级阻塞</strong>（系统认为会很快就绪的）进程和低优先级就绪进程时，系统会选择挂起低优先级就绪进程</li>
<li><strong>阻塞挂起</strong>：活动阻塞到静止阻塞，无进程处于<strong>就绪进程</strong>要求更多内存资源时，会进行这种转换，以提交新进程或运行就绪进程</li>
<li><strong>运行到就绪挂起</strong>：对抢占式分时系统，当有高优先级阻塞挂起进程因事件出现而进入就绪挂起时，系统可能会把运行进程转到就绪挂起状态</li>
</ul>
</li>
<li>激活（Activate）：进程从外存转到内存
<ul>
<li><strong>就绪激活</strong>：静止就绪到活动就绪，<strong>没有就绪进程</strong>或<strong>挂起就绪进程优先级高于就绪进程</strong>时，会进行这种转换；</li>
<li><strong>阻塞激活</strong>：静止阻塞到活动阻塞，<strong>当一个进程释放足够内存时</strong>，系统会把一个高优先级阻塞挂起（系统认为会很快出现所等待的事件）进程激活；</li>
</ul>
</li>
</ul>
<hr />
<ul>
<li>执行的进程暂停</li>
<li>就绪的进程暂不调度</li>
<li>阻塞的进程即使引起阻塞的事件消失也不调度</li>
</ul>
<h3 id="转换"><a class="markdownIt-Anchor" href="#转换"></a> 转换</h3>
<ul>
<li><strong>事件出现</strong>(Event Occurs) ：进程等待的事件出现，如：操作完成、申请成功等；</li>
<li>可能的情况有：
<ul>
<li>阻塞到就绪：针对内存进程的事件出现；</li>
<li>阻塞挂起到就绪挂起：针对外存进程的事件出现；</li>
</ul>
</li>
<li><strong>收容</strong>(Admit)：收容一个新进程，进入就绪状态或就绪挂起状态。进入就绪挂起的原因是系统希望<strong>保持一个大的就绪进程表</strong>（挂起和非挂起）；<br />
<img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://gitee.com/zoruasama/Zorua-Pic/raw/master/20200502182726.png" alt="" /></li>
</ul>
<h2 id="进程控制块"><a class="markdownIt-Anchor" href="#进程控制块"></a> 进程控制块</h2>
<ul>
<li>进程控制块的作用
<ul>
<li>是使一个在多道程序环境下不能独立运行的程序(含数据)，成为一个能独立运行的基本单位，一个能与其它进程并发执行的进程。或者说，OS是根据PCB来对并发执行的进程进行控制和管理的。</li>
<li>是系统感知进程存在的惟一标志。</li>
</ul>
</li>
<li>进程控制块中的信息有：
<ul>
<li>进程标识符</li>
<li>处理机状态</li>
<li>进程调度信息</li>
<li>进程控制信息</li>
</ul>
</li>
</ul>
<h3 id="进程控制块中的信息"><a class="markdownIt-Anchor" href="#进程控制块中的信息"></a> 进程控制块中的信息</h3>
<h4 id="进程标识符"><a class="markdownIt-Anchor" href="#进程标识符"></a> 进程标识符</h4>
<ul>
<li><strong>进程标识符</strong>用于惟一地<strong>标识</strong>一个进程。一个进程通常有两种标识符：
<ul>
<li><strong>内部标识符</strong>——在所有的操作系统中，都为每一个进程赋予一个惟一的数字标识符，它通常是一个进程的序号。设置内部标识符主要是为了方便系统使用。</li>
<li><strong>外部标识符</strong>——它由创建者提供，通常是由字母、数字组成，往往是由用户(进程)在访问该进程时使用。为了描述进程的家族关系， 还应设置父进程标识及子进程标识。此外，还可设置用户标识，以指示拥有该进程的用户。</li>
</ul>
</li>
</ul>
<h4 id="处理机状态"><a class="markdownIt-Anchor" href="#处理机状态"></a> 处理机状态</h4>
<ul>
<li>处理机状态（CPU现场保护区）</li>
<li>主要是由CPU的各种<strong>寄存器</strong>中的内容组成的：
<ul>
<li><strong>通用寄存器</strong>——又称为用户可视寄存器，是用户程序可以访问的，用于暂存信息， 在大多数处理机中，有 8~32 个通用寄存器，在RISC结构的计算机中可超过 100 个；</li>
<li><strong>指令计数器</strong>——其中存放了要访问的下一条指令的地址；</li>
<li><strong>程序状态字PSW</strong>——其中含有状态信息，如条件码、执行方式、中断屏蔽标志等；</li>
<li><strong>用户栈指针</strong>——指每个用户进程都有一个或若干个与之相关的系统栈，用于存放过程和系统调用参数及调用地址。栈指针指向该栈的栈顶</li>
</ul>
</li>
</ul>
<h4 id="进程调度信息"><a class="markdownIt-Anchor" href="#进程调度信息"></a> 进程调度信息</h4>
<ul>
<li>存放与进程调度和进程对换有关的信息，包括:
<ul>
<li><strong>进程状态</strong>——指明进程的当前状态， 作为进程调度和对换时的依据；</li>
<li><strong>进程优先级</strong>——用于描述进程使用处理机的优先级别的一个整数，调度的依据，高者优先获得处理机；</li>
<li><strong>进程调度所需的其它信息</strong>——它们与所采用的进程调度算法有关，比如，进程已等待CPU的时间总和、 进程已执行的时间总和等；</li>
<li><strong>事件</strong>——是指进程由执行状态转变为阻塞状态所等待发生的事件，即阻塞原因</li>
</ul>
</li>
</ul>
<h4 id="进程控制信息"><a class="markdownIt-Anchor" href="#进程控制信息"></a> 进程控制信息</h4>
<ul>
<li><strong>程序和数据的地址</strong>——是指进程的程序和数据所在的内存或外存地(首)址，以便再调度到该进程执行时，能从PCB中找到其程序和数据；</li>
<li><strong>进程同步和通信机制</strong>——指实现进程同步和进程通信时必需的机制， 如消息队列指针、信号量等，它们可能全部或部分地放在PCB中；</li>
<li><strong>占用资源清单</strong>——列出了除CPU以外的、进程所需的全部资源及已经分配到该进程的资源的清单；</li>
<li><strong>链接指针</strong>——它给出了本进程(PCB)所在队列中的下一个进程的PCB的首地址</li>
<li><strong>家族联系</strong>—— 指明本进程与家族的关系，如它的子进程与父进程的标识</li>
</ul>
<h3 id="进程控制块的组织方式"><a class="markdownIt-Anchor" href="#进程控制块的组织方式"></a> 进程控制块的组织方式</h3>
<h4 id="链接方式"><a class="markdownIt-Anchor" href="#链接方式"></a> 链接方式</h4>
<p>把具有同一状态的PCB用其中的链接字链接成一个队列，可以形成<strong>就绪队列</strong>、若干个<strong>阻塞队列</strong>和<strong>空白队列</strong>。<br />
<img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://gitee.com/zoruasama/Zorua-Pic/raw/master/20200502191523.png" alt="" /></p>
<h4 id="索引方式"><a class="markdownIt-Anchor" href="#索引方式"></a> 索引方式</h4>
<p>系统根据所有进程的状态建立几张索引表，如<strong>就绪索引表、阻塞索引表</strong>等，并把各索引表在内存的首地址记录在专用单元中。索引表中记录的是PCB在PCB表中的地址。<br />
<img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://gitee.com/zoruasama/Zorua-Pic/raw/master/20200502191614.png" alt="" /></p>
<h1 id="进程控制"><a class="markdownIt-Anchor" href="#进程控制"></a> 进程控制</h1>
<ul>
<li>职责是对系统中全部进程实施有效管理，包括
<ul>
<li>创建新进程</li>
<li>终止已结束进程</li>
<li>终止由于某事件而无法运行下去的进程</li>
<li>负责进程的状态转换</li>
</ul>
</li>
<li>这些功能一般由操作系统的<strong>内核</strong>实现，操作系统的内核是基于硬件的第一次扩充。把与硬件紧密相关的模块、运行频率较高的模块及一些公用的基本操作安排在靠近硬件的软件层次中，并<strong>常驻内存</strong>，以提高系统运行效率。</li>
</ul>
<blockquote>
<p>这些进程控制功能是通过执行各种原语实现的。</p>
</blockquote>
<h2 id="操作系统内核"><a class="markdownIt-Anchor" href="#操作系统内核"></a> 操作系统内核</h2>
<ul>
<li>OS内核是计算机硬件的第一层软件扩充，常驻内存。</li>
<li>例：中断处理程序、设备驱动程序以及时钟管理、进程调度等。</li>
</ul>
<h3 id="支撑功能"><a class="markdownIt-Anchor" href="#支撑功能"></a> 支撑功能</h3>
<ul>
<li><strong>中断处理</strong>：最基本的功能，是OS的基础。</li>
<li><strong>时钟管理</strong>：为基本功能，如分时系统的时间片，实时系统的时间控制。</li>
<li><strong>原语操作</strong>：是原子操作（是不可分割的操作），用来执行基本操作。创建、撤销、阻塞、唤醒、挂起、激活。</li>
</ul>
<h3 id="资源管理功能"><a class="markdownIt-Anchor" href="#资源管理功能"></a> 资源管理功能</h3>
<ul>
<li>进程管理：放在内核。例：调度、分派、创建、撤销、同步、通信。运行频率高。</li>
<li>存储器管理：内存分配、回收、保护、对换等放在内核，保证运行速度高。</li>
<li>设备管理：驱动程序、缓冲管理、设备分配等。</li>
</ul>
<hr />
<ul>
<li>原语(primitive)
<ul>
<li>由若干条指令构成的“原子操作(atomic operation)”过程，作为一个整体而不可分割——要么全都做，要么全不做</li>
<li>系统调用并不都是原语  进程A调用read()，因无数据而阻塞，在read()里未返回。然后进程B调用read()，此时read()被重入。系统调用不一定一次执行完并返回该进程，有可能在特定的点暂停，而转入到其他进程</li>
</ul>
</li>
<li>处理机的执行状态——<strong>保护系统程序</strong>
<ul>
<li>核心态（管态、系统态）系统管理程序执行时的状态。具有较高的特权，能执行一切指令，访问所有的寄存器和存储区</li>
<li>用户态（目态）以后程序执行时的状态。具有较低的特权，只能执行规定指令，访问指定的寄存器和存储区</li>
</ul>
</li>
</ul>
<h2 id="进程的创建"><a class="markdownIt-Anchor" href="#进程的创建"></a> 进程的创建</h2>
<ul>
<li>进程图(Process Graph)
<ul>
<li>是用于描述一个进程的家族关系的有向树，树中的结点表示进程</li>
<li>在进程<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">P_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>创建了进程<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">P_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>之后称<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">P_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">P_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>的父进程(Parent Process)，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">P_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">P_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的子进程(Progeny Process)。创建父进程的进程称为祖先进程，把树的根结点称为进程家族的祖先进程(Ancestor)。</li>
</ul>
</li>
<li>子进程可以<strong>继承</strong>(Inherit)父进程的<strong>资源</strong></li>
<li><strong>撤消</strong>父进程时必须同时<strong>撤消</strong>子进程</li>
</ul>
<h3 id="引起创建进程的事件"><a class="markdownIt-Anchor" href="#引起创建进程的事件"></a> 引起创建进程的事件</h3>
<ul>
<li>在多道程序环境中，要运行程序，必须为其创建进程</li>
<li>用户登录
<ul>
<li>分时系统的用户在终端登录后，如是合法用户，系统将为其创建一个进程，并插入就绪队列</li>
</ul>
</li>
<li>作业调度
<ul>
<li>在批处理系统中，当作业调度程序调度到某作业时，将该作业装入内存，为它分配资源并创建进程</li>
</ul>
</li>
<li>提供服务
<ul>
<li>当运行中的用户进程提出某种请求后，系统将专门创建一个进程来提供服务，如打印</li>
</ul>
</li>
<li>应用请求
<ul>
<li>由应用程序为自己创建进程，以便能并发执行，如输入、计算、输出程序</li>
</ul>
</li>
</ul>
<h3 id="创建流程"><a class="markdownIt-Anchor" href="#创建流程"></a> 创建流程</h3>
<ol>
<li>申请空白PCB  为新进程申请惟一的数字标识符，并从PCB集合中索取一个空白PCB</li>
<li>为新进程<strong>分配资源</strong>  为新进程的程序和数据<strong>分配内存</strong>。对于<strong>批处理</strong>型作业，可在用户提出创建进程时要求提供所需内存大小。对于<strong>交互型</strong>作业可以由系统来分配一定的空间</li>
<li>初始化进程控制块
<ol>
<li><strong>初始化标识信息</strong>——将系统标识信息写入新PCB</li>
<li><strong>初始化处理机状态信息</strong>——使程序计数器指向程序的入口地址，栈指针指向栈顶</li>
<li><strong>初始化处理机控制信息</strong>——将进程的状态设为就绪状态或静止就绪状态</li>
</ol>
</li>
<li>将新进程<strong>插入就绪队列</strong>   如果进程就绪队列能够接纳新进程，便将新进程插入就绪队列</li>
</ol>
<h2 id="进程的终止"><a class="markdownIt-Anchor" href="#进程的终止"></a> 进程的终止</h2>
<ul>
<li>引起进程终止(Termination of Process)的事件
<ul>
<li>正常结束</li>
<li>异常结束</li>
<li>外界干预</li>
</ul>
</li>
</ul>
<h3 id="正常结束"><a class="markdownIt-Anchor" href="#正常结束"></a> 正常结束</h3>
<p>应有一个通知OS进程已经运行完成的指令。如，在批处理系统中，通常在程序最后安排一条<strong>Halt指令</strong>或<strong>终止的系统调用</strong>。当程序执行Halt指令时，将产生一个中断，通知OS本进程已经完成。 在分时系统中，用户可利用<strong>Logs off</strong>去表示进程运行完毕， 此时同样产生一个中断，告知OS进程已运行完毕。</p>
<h3 id="异常结束"><a class="markdownIt-Anchor" href="#异常结束"></a> 异常结束</h3>
<p>在进程运行期间，由于出现某些错误和故障而迫使进程终止。</p>
<ul>
<li>越界错误——这是指程序所访问的存储区，已越出该进程的区域。</li>
<li>保护错——进程试图访问一不允许访问的资源或文件，或者以不适当的方式进行访问，如进程试图去写一个只读文件。</li>
<li>非法指令——程序试图去执行一条不存在的指令。出现该错误的原因，可能是程序错误地转移到数据区，把数据当成了指令。</li>
<li>特权指令错——用户进程试图去执行一条只允许OS执行的指令。</li>
<li>运行超时——进程的执行时间超过了指定的最大值；</li>
<li>等待超时——进程等待某事件的时间， 超过了规定的最大值；</li>
<li>算术运算错——进程试图去执行一个被禁止的运算，如被0除；</li>
<li>I/O故障——这是指在I/O过程中发生了错误等。</li>
</ul>
<h3 id="外界干预"><a class="markdownIt-Anchor" href="#外界干预"></a> 外界干预</h3>
<ul>
<li>外界干预并非指在本进程运行中出现了异常事件，而是指进程应外界的请求而终止运行
<ul>
<li>操作员或操作系统干预——由于某种原因，例如，发生了死锁，由操作员或操作系统终止该进程</li>
<li>父进程请求——由于父进程具有终止自己的任何子孙进程的权利， 因而当父进程提出请求时，系统将终止该进程；</li>
<li>父进程终止——当父进程终止时，OS也将他的所有子孙进程终止</li>
</ul>
</li>
</ul>
<h3 id="进程的终止过程"><a class="markdownIt-Anchor" href="#进程的终止过程"></a> 进程的终止过程</h3>
<ol>
<li>根据被终止进程的标识符，从PCB集合中检索出该进程的PCB，从中读出该进程的状态</li>
<li>若被终止进程<strong>正处于执行状态</strong>，应立即终止该进程的执行，并置调度标志为<strong>真</strong>，以便进程撤消后将处理机分配给其他进程</li>
<li>若该进程还有<strong>子孙进程</strong>，还应将其所有子孙进程予以终止，以防他们成为不可控的进程</li>
<li>将被终止进程所拥有的<strong>全部资源</strong>，或者归还给其父进程， 或者归还给系统</li>
<li>撤消PCB</li>
</ol>
<h2 id="进程的阻塞与唤醒"><a class="markdownIt-Anchor" href="#进程的阻塞与唤醒"></a> 进程的阻塞与唤醒</h2>
<h3 id="引起进程阻塞和唤醒的事件"><a class="markdownIt-Anchor" href="#引起进程阻塞和唤醒的事件"></a> 引起进程阻塞和唤醒的事件</h3>
<ul>
<li>请求系统服务
<ul>
<li>如请求打印机时，若<strong>已被</strong>其他进程<strong>占用</strong>，此时只能<strong>阻塞</strong>，等其他进程<strong>释放</strong>后再将请求进程<strong>唤醒</strong></li>
</ul>
</li>
<li>启动某种操作
<ul>
<li>当进程启动某种操作后，如果该进程<strong>必须在该操作完成后才能继续执行</strong>，则必须先使进程阻塞，以等待该操作完成。如启动I/O设备</li>
</ul>
</li>
<li>新数据尚未到达
<ul>
<li>对于相互合作的进程，如果一个进程需要另一合作进程提供的数据，则在<strong>数据到达之前只能阻塞</strong></li>
</ul>
</li>
<li>无新工作可做
<ul>
<li>系统中的一些特殊功能进程，在完成了任务之后，<strong>等待新任务到来</strong>。如系统中的发送进程</li>
</ul>
</li>
</ul>
<h3 id="进程阻塞过程"><a class="markdownIt-Anchor" href="#进程阻塞过程"></a> 进程阻塞过程</h3>
<ul>
<li><strong>正在执行的进程</strong>，当发现上述某事件时，因无法继续执行，进程便通过调用<strong>阻塞原语</strong>block()把自己阻塞。可见，进程的<strong>阻塞是</strong>进程<strong>自身</strong>的一种<strong>主动行为</strong></li>
<li>进入block过程后，由于此时该进程还处于执行状态，所以应<strong>先立即停止执行</strong>，把进程控制块中的现行状态由“执行”改为阻塞，并将PCB插入阻塞队列</li>
<li>若系统中设置了因不同事件而阻塞的多个<strong>阻塞队列</strong>，则将本进程插入到具有相同事件的阻塞(等待)队列</li>
<li>调度程序进行<strong>重新调度</strong>，将处理机分配给另一就绪进程，并进行切换，亦即，保留被阻塞进程的处理机状态(在PCB中)，再按新进程的PCB中的处理机状态设置CPU的环境</li>
</ul>
<h3 id="进程唤醒过程"><a class="markdownIt-Anchor" href="#进程唤醒过程"></a> 进程唤醒过程</h3>
<ul>
<li>当被阻塞进程<strong>所期待的事件出现</strong>时，如I/O完成或其所期待的数据已经到达，则由有关进程(比如，用完并释放了该I/O设备的进程)调用<strong>唤醒原语</strong>wakeup()，将等待该事件的进程唤醒</li>
<li>唤醒原语执行的过程是
<ol>
<li>把被阻塞的进程从等待该事件的阻塞队列中移出</li>
<li>将其PCB中的现行状态由<strong>阻塞</strong>改为<strong>就绪</strong></li>
<li>将该PCB插入到就绪队列中</li>
</ol>
</li>
</ul>
<hr />
<blockquote>
<p>应当指出，<strong>block原语</strong>和<strong>wakeup原语</strong>是一对作用刚好相反的原语。因此，如果在某进程中调用了阻塞原语，则必须在与之相合作的另一进程中或其他相关的进程中，安排唤醒原语，以能唤醒阻塞进程；否则，被阻塞进程将会因不能被唤醒而长久的处于阻塞状态，从而再无机会继续运行。</p>
</blockquote>
<h2 id="进程的挂起与激活"><a class="markdownIt-Anchor" href="#进程的挂起与激活"></a> 进程的挂起与激活</h2>
<h3 id="进程的挂起"><a class="markdownIt-Anchor" href="#进程的挂起"></a> 进程的挂起</h3>
<ul>
<li>当<strong>出现引起进程挂起的事件</strong>时，比如，用户进程请求将自己挂起，或父进程请求将自己的某个子进程挂起，系统将利用<strong>挂起原语</strong>suspend( )将指定进程或处于阻塞状态的进程挂起。</li>
</ul>
<ol>
<li>执行的进程暂停</li>
<li>就绪的进程暂不调度</li>
<li>阻塞的进程即使引起阻<br />
塞的事件消失也不调度</li>
</ol>
<h4 id="挂起原语的执行过程"><a class="markdownIt-Anchor" href="#挂起原语的执行过程"></a> 挂起原语的执行过程</h4>
<ol>
<li>得到挂起进程的内部标识符</li>
<li>首先检查被挂起进程的状态，若处于<strong>活动就绪</strong>状态，便将其改为<strong>静止就绪</strong>；对于<strong>活动阻塞</strong>状态的进程，则将之改为<strong>静止阻塞</strong></li>
<li>为了方便用户或父进程考查该进程的运行情况而把该进程的PCB复制到某指定的内存区域</li>
<li>若被挂起的进程正在执行，则转向调度程序重新调度</li>
</ol>
<h3 id="进程的激活"><a class="markdownIt-Anchor" href="#进程的激活"></a> 进程的激活</h3>
<ul>
<li>当发生激活进程的事件时，如，父进程或用户进程请求激活指定进程，若该进程驻留在外存而内存中已有足够的空间时，则可将在外存上处于静止就绪状态的进程换入内存。这时，系统将利用<strong>激活原语</strong>active( )将指定进程激活</li>
</ul>
<h4 id="激活原语执行过程"><a class="markdownIt-Anchor" href="#激活原语执行过程"></a> 激活原语执行过程</h4>
<ul>
<li>激活原语先将进程从外存<strong>调入内存</strong>，检查该进程的现行状态，若是<strong>静止就绪</strong>，便将之改为<strong>活动就绪</strong>；若为<strong>静止阻塞</strong>便将之改为<strong>活动阻塞</strong>。</li>
<li>若采用抢占调度策略，则每当有<strong>新进程</strong>（激活）进入就绪队列时，应<strong>检查</strong>是否要进行重新调度，即由调度程序将被激活进程与当前进程进行优先级的比较，如果被激活进程的优先级更低，就不必重新调度；否则，<strong>立即剥夺</strong>当前进程的运行，把处理机分配给刚被激活的进程。</li>
</ul>
<h1 id="进程同步"><a class="markdownIt-Anchor" href="#进程同步"></a> 进程同步</h1>
<p>进程同步的主要任务，是使并发执行的诸进程之间能有效的<strong>共享资源</strong>和<strong>相互合作</strong>，从而使程序的执行具有可再现性。</p>
<h2 id="进程同步的基本概念"><a class="markdownIt-Anchor" href="#进程同步的基本概念"></a> 进程同步的基本概念</h2>
<ul>
<li>两种形式的制约关系
<ul>
<li>在多道程序环境下，当程序并发执行时，由于<strong>资源共享</strong>和<strong>进程合作</strong>，使同处于系统中的诸进程之间存在两种形式的制约关系</li>
</ul>
</li>
<li>间接相互制约关系
<ul>
<li>同处于一个系统中的进程必然<strong>共享某种资源</strong>，如CPU、I/O设备等，间接相互制约即源于资源共享。如A、B共享打印机，若A申请打印时，打印机已分配给B，则A只能阻塞，等B释放后再改为就绪，又称为&quot;<strong>互斥</strong>&quot;</li>
</ul>
</li>
<li>直接相互制约关系
<ul>
<li>这种制约源于<strong>进程之间的合作</strong>关系。如进程A向B提供数据，当输入缓冲空时，B不能得到数据而阻塞；反之当缓冲满时，A无法写入而阻塞，又称为&quot;<strong>同步</strong>&quot;。</li>
</ul>
</li>
</ul>
<h3 id="进程同步的原因"><a class="markdownIt-Anchor" href="#进程同步的原因"></a> 进程同步的原因</h3>
<p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://gitee.com/zoruasama/Zorua-Pic/raw/master/20200503234523.png" alt="" /></p>
<p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://gitee.com/zoruasama/Zorua-Pic/raw/master/20200503234847.png" alt="" /></p>
<table>
<thead>
<tr>
<th>相互感知的程度</th>
<th>相互关系</th>
<th>一个进程对其他进程的影响</th>
<th>潜在的控制问题</th>
</tr>
</thead>
<tbody>
<tr>
<td>相互不感知(完全不了解其它进程的存在)</td>
<td>竞争(competition)</td>
<td>一个进程的操作对其他进程的结果无影响</td>
<td>互斥，死锁（可释放的资源），饥饿</td>
</tr>
<tr>
<td>间接感知(双方都与第三方交互，如共享资源)</td>
<td>通过共享进行协作</td>
<td>一个进程的结果依赖于从其他进程获得的信息</td>
<td>互斥，死锁（可释放的资源），饥饿，数据一致性</td>
</tr>
<tr>
<td>直接感知(双方直接交互，如通信)</td>
<td>通过通信进行协作</td>
<td>一个进程的结果依赖于从其他进程获得的信息</td>
<td>死锁，饥饿</td>
</tr>
</tbody>
</table>
<ul>
<li><strong>互斥</strong>，指多个进程不能同时使用同一个资源；</li>
<li><strong>死锁</strong>，指多个进程互不相让，都得不到足够的资源；</li>
<li><strong>饥饿</strong>，指一个进程一直得不到资源（其他进程可能轮流占用资源）</li>
</ul>
<h3 id="临界资源critical-resouce"><a class="markdownIt-Anchor" href="#临界资源critical-resouce"></a> 临界资源(Critical Resouce)</h3>
<ul>
<li>临界资源(Critical Resouce)</li>
<li><strong>一次仅允许一个</strong>进程使用的资源</li>
<li>系统中许多硬件如打印机等，诸进程之间只能用互斥的方式进行访问</li>
</ul>
<h4 id="生产者-消费者producer-consumer问题"><a class="markdownIt-Anchor" href="#生产者-消费者producer-consumer问题"></a> 生产者-消费者(producer-consumer)问题</h4>
<ul>
<li>有一群生产者进程在生产产品，并将这些产品提供给消费者进程去消费。为使生产者进程与消费者进程能并发执行，在两者之间设置了一个具有n个<strong>缓冲区的缓冲池</strong>，生产者进程将它所生产的产品放入一个缓冲区中；消费者进程可从一个缓冲区中取走产品去消费。尽管所有的生产者进程和消费者进程都是以<strong>异步</strong>方式运行的，但它们之间必须保持<strong>同步</strong>，即不允许消费者进程到一个空缓冲区去取产品；也不允许生产者进程向一个已装满产品且尚未被取走的缓冲区中投放产品</li>
<li>生产者-消费者问题——解决思路
<ul>
<li>利用一个数组来表示上述的具有n个(0，1，…，n-1)缓冲区的缓冲池。用输入指针in来指示下一个可投放产品的缓冲区，每当生产者进程生产并投放一个产品后，输入指针加1；用一个输出指针out来指示下一个可从中获取产品的缓冲区，每当消费者进程取走一个产品后，输出指针加1。</li>
<li>设缓冲池的组织是循环缓冲，故应把输入指针加1表示成 in:=(in+1)mod n；输出指针加1表示成out:=(out+1) mod n</li>
<li>当(in+1) mod n=out时表示缓冲池满；in=out则表示缓冲池空</li>
<li>引入了一个整型变量counter, 其初始值为0。每当生产者进程向缓冲池中投放一个产品后，使counter加1；反之，每当消费者进程从中取走一个产品时， 使counter减1</li>
</ul>
</li>
<li>生产者-消费者问题——解决思路</li>
<li>生产者和消费者两进程共享下面的变量</li>
</ul>
<figure class="highlight pascal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Var</span> n : integer;</span><br><span class="line"><span class="keyword">type</span> item=…;   <span class="comment">//定义缓冲区的类型</span></span><br><span class="line"><span class="keyword">var</span> buffer:<span class="keyword">array</span>［<span class="number">0</span>, <span class="number">1</span>, …, n-<span class="number">1</span>］ <span class="keyword">of</span> item; <span class="comment">//分配缓冲区</span></span><br><span class="line"><span class="keyword">in</span>, <span class="keyword">out</span>: <span class="number">0</span>, <span class="number">1</span>, …, n-<span class="number">1</span>;  <span class="comment">//定义指针</span></span><br><span class="line">counter: <span class="number">0</span>, <span class="number">1</span>, …, n; <span class="comment">//定义计数器</span></span><br></pre></td></tr></table></figure>
<p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://gitee.com/zoruasama/Zorua-Pic/raw/master/20200504001050.png" alt="" /></p>
<ul>
<li>指针in和out初始化为1
<ul>
<li>设no-op是一条空操作指令，则对于生产者当counter=n时，应执行 no-op ，而对于消费者进程当counter=0时应执行no-op</li>
<li>在生产者进程中设一局部变量nextp，用于暂时存放每次刚生产出来的产品；而在消费者进程中，则设一个局部变量nextc，用于存放每次要消费的产品</li>
</ul>
</li>
</ul>
<figure class="highlight pascal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">producer: <span class="keyword">repeat</span>                       <span class="comment">//*生产者进程</span></span><br><span class="line">           …</span><br><span class="line">           produce an item <span class="keyword">in</span> nextp;   <span class="comment">//生产一个产品</span></span><br><span class="line">           …</span><br><span class="line">           <span class="keyword">while</span> counter=n <span class="keyword">do</span> no-op;</span><br><span class="line">           buffer［<span class="keyword">in</span>］∶=nextp;   <span class="comment">//将产品存入缓冲区</span></span><br><span class="line">           <span class="keyword">in</span>∶=<span class="keyword">in</span>+<span class="number">1</span> <span class="keyword">mod</span> n;            <span class="comment">//修改缓冲区指针</span></span><br><span class="line">           counter∶=counter+<span class="number">1</span>;    <span class="comment">//修改计数器</span></span><br><span class="line">           <span class="keyword">until</span> false;</span><br><span class="line">consumer: <span class="keyword">repeat</span>                      <span class="comment">//*消费者进程</span></span><br><span class="line">           <span class="keyword">while</span> counter=<span class="number">0</span> <span class="keyword">do</span> no-op;</span><br><span class="line">           nextc∶ =buffer［<span class="keyword">out</span>］;</span><br><span class="line">			<span class="keyword">out</span>∶= (<span class="keyword">out</span>+<span class="number">1</span>) <span class="keyword">mod</span> n;</span><br><span class="line">           counter∶ =counter-<span class="number">1</span>;</span><br><span class="line">           consume the item <span class="keyword">in</span> nextc;</span><br><span class="line">           <span class="keyword">until</span> false;</span><br></pre></td></tr></table></figure>
<p>虽然上面的生产者程序和消费者程序，在分别看时都是正确的，而且两者在顺序执行时其结果也会是正确的，但若并发执行时，就会出现差错，问题就在于这两个进程共享变量counter。生产者对它做加1操作，消费者对它做减1操作，这两个操作在用机器语言实现时， 常可用下面的形式描述</p>
<figure class="highlight pascal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//生产者：                        消费者：</span></span><br><span class="line"> register1:=counter;              register2:=counter;</span><br><span class="line"> register1:=register1+<span class="number">1</span>;         register2:=register2-<span class="number">1</span>;</span><br><span class="line"> counter:=register1;              counter:=register2;</span><br><span class="line"> ...                              ...</span><br></pre></td></tr></table></figure>
<p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://gitee.com/zoruasama/Zorua-Pic/raw/master/20200504001632.png" alt="" /></p>
<h3 id="临界区critical-section"><a class="markdownIt-Anchor" href="#临界区critical-section"></a> 临界区（critical section）</h3>
<ul>
<li>不论是<strong>硬件临界资源</strong>还是<strong>软件临界资源</strong>，多个进程必须互斥地对它进行访问</li>
<li>在每个进程中访问临界资源的那段代码称为<strong>临界区</strong>(critical section)</li>
<li>每个进程进入临界区之前应先对<strong>欲访问的临界资源进行检查</strong>，看是否正在被访问。如果此刻该临界资源未被访问，该进程可进入临界区，并设置它正在被访问的标志，在临界区<strong>之前</strong>执行的这段代码称为<strong>进入区</strong>（entry section）</li>
<li>在临界区<strong>之后</strong>也要加上一段代码，用于将临界区被访问的标志恢复为未被访问的标志，称为<strong>退出区</strong>（exit section）<br />
<img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://gitee.com/zoruasama/Zorua-Pic/raw/master/20200504001746.png" alt="" /></li>
</ul>
<h3 id="同步机制应遵循的规则"><a class="markdownIt-Anchor" href="#同步机制应遵循的规则"></a> 同步机制应遵循的规则</h3>
<ul>
<li>空闲让进
<ul>
<li>当无进程处于临界区时，应允许一个进程进入临界区</li>
</ul>
</li>
<li>忙则等待
<ul>
<li>当已有进程进入临界区时，其他进程必须等待</li>
</ul>
</li>
<li>有限等待
<ul>
<li>对要求访问临界资源的进程，应保证在有限时间内进入自己的临界区，防止&quot;死等&quot;</li>
</ul>
</li>
<li>让权等待
<ul>
<li>当进程不能进入自己的临界区时，应立即释放处理机，防止&quot;忙等&quot;</li>
</ul>
</li>
</ul>
<h2 id="信号量机制"><a class="markdownIt-Anchor" href="#信号量机制"></a> 信号量机制</h2>
<ul>
<li>1965年，荷兰学者Dijkstra提出的信号量（Semaphores）机制是一种有效的进程同步工具,所以P、V分别是荷兰语的test(proberen)和increment(verhogen)</li>
<li>信号量机制已从整型信号量发展为记录型信号量，又进一步发展为信号量集</li>
<li>目前，信号量机制已广泛应用于单处理机、多处理机以及计算机网络中</li>
<li><strong>信号量</strong>就是OS提供的管理公有资源的有效手段</li>
<li><strong>信号量代表可用资源实体的数量</strong></li>
</ul>
<h3 id="整型信号量"><a class="markdownIt-Anchor" href="#整型信号量"></a> 整型信号量</h3>
<ul>
<li>最初由Dijkstra把整型信号量定义为一个整型量，除初始化外，仅能通过两个标准的原子操作wait(S)和signal(S)来访问。这两个操作一直被分别称为P、V操作。 wait和signal操作可描述为：</li>
</ul>
<figure class="highlight pascal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wait(S):    <span class="keyword">while</span> S≤<span class="number">0</span> <span class="keyword">do</span> no-op</span><br><span class="line">    S∶=S-<span class="number">1</span>;</span><br><span class="line">signal(S):  S∶=S+<span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>wait(S)和signal(S)是<strong>原子操作</strong>，执行时是不可中断的。另外，在wait操作中，对S的测试和做S∶=S-1操作时都不可中断，<strong>信号量只能通过原语操作来访问</strong>，不能被进程调度所打断</li>
<li>缺点：信号量S≤0时“<strong>忙等</strong>”，未遵循“<strong>让权等待</strong>”</li>
</ul>
<h3 id="记录型信号量"><a class="markdownIt-Anchor" href="#记录型信号量"></a> 记录型信号量</h3>
<ul>
<li><strong>采取了“让权等待”的策略</strong>，是一种不存在“忙等”现象的进程同步机制。</li>
<li>在采取了“让权等待”的策略后，又会出现多个进程等待访问同一临界资源的情况。为此，在记录型信号量机制中，除了需要一个用于代表<strong>资源数目</strong>的整型变量value外，还应增加一个<strong>进程链表L</strong>，用于链接上述的所有等待进程。</li>
<li>记录型信号量是由于它采用了记录型的数据结构而得名的，定义如下：</li>
</ul>
<figure class="highlight pascal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> semaphore=<span class="keyword">record</span></span><br><span class="line">     value:integer;</span><br><span class="line">     L:list <span class="keyword">of</span> process;</span><br></pre></td></tr></table></figure>
<ul>
<li>相应地，wait(S)和signal(S)操作可描述为：</li>
</ul>
<figure class="highlight pascal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">wait</span><span class="params">(S)</span></span></span><br><span class="line"><span class="function">      <span class="title">var</span> <span class="title">S</span>:</span> semaphore;</span><br><span class="line">      <span class="keyword">begin</span></span><br><span class="line">         S.value:=S.value-<span class="number">1</span>;        <span class="comment">// 请求一个该类资源</span></span><br><span class="line">         <span class="keyword">if</span> S.value＜<span class="number">0</span> <span class="keyword">then</span> block(S.L);   <span class="comment">//该类资源已分配完毕,调用block原语，进行自我阻塞并放弃处理机、插入到信号量链表S.L中</span></span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">signal</span><span class="params">(S)</span></span></span><br><span class="line"><span class="function">      <span class="title">var</span> <span class="title">S</span>:</span> semaphore;</span><br><span class="line">      <span class="keyword">begin</span></span><br><span class="line">         S.value:=S.value+<span class="number">1</span>;</span><br><span class="line">         <span class="keyword">if</span> S.value≤<span class="number">0</span> <span class="keyword">then</span> wakeup(S.L);</span><br><span class="line">      <span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<ul>
<li>在记录型信号量机制中，S.value的初值表示系统中某类资源的数目， 因而又称为资源信号量</li>
<li>对信号量S.value每次wait操作，<code>·S.value:=S.value-1</code>
<ul>
<li><code>S.value&gt;0</code>时，有该类资源</li>
<li><code>S.value＜0</code>时，该类资源已分配完毕，|S.value|=该信号量链表中<strong>已阻塞进程的数目</strong></li>
</ul>
</li>
<li>对信号量的每次signal操作，<code>S.value:=S.value+1</code>
<ul>
<li>若加1后仍是S.value≤0，表示在该信号量链表中仍有等待该资源的进程被阻塞，则应调用wakeup原语，将S.L链表中的第一个等待进程唤醒。</li>
<li>若S.value的初值为1，表示只允许一个进程访问临界资源，此时的信号量转化为<strong>互斥信号量</strong></li>
</ul>
</li>
</ul>
<h3 id="and型信号量"><a class="markdownIt-Anchor" href="#and型信号量"></a> AND型信号量</h3>
<ul>
<li>在有些任务中，一个进程先要获得多个共享资源后才能执行，若进程A和B都要访问共享数据D和E，设信号量Dmutex和Emutex (MUTual Exclusion)的初值均为1</li>
<li>在两个进程中都要包含两个对<code>Dmutex</code>和<code>Emutex</code>的操作， 即</li>
</ul>
<figure class="highlight pascal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//process A:        	 process B:</span></span><br><span class="line">wait(Dmutex); 	     wait(Emutex);</span><br><span class="line">wait(Emutex);  	     wait(Dmutex);</span><br></pre></td></tr></table></figure>
<ul>
<li>若进程A和B按下述次序交替执行wait操作：</li>
</ul>
<figure class="highlight pascal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">process A: wait(Dmutex); <span class="comment">//于是Dmutex=0</span></span><br><span class="line">process B: wait(Emutex); <span class="comment">//于是Emutex=0</span></span><br><span class="line">process A: wait(Emutex); <span class="comment">//于是Emutex=-1 A阻塞</span></span><br><span class="line">process B: wait(Dmutex); <span class="comment">//于是Dmutex=-1 B阻塞</span></span><br></pre></td></tr></table></figure>
<ul>
<li>AND同步机制的基本思想是
<ul>
<li>将进程在整个运行过程中需要的所有资源，<strong>一次性全部地分配给进程</strong>，待进程使用完后再一起释放。只要尚有一个资源未能分配给进程，其它所有可能为之分配的资源，也不分配给他。亦即，对若干个临界资源的分配，采取原子操作方式：要么全部分配到进程，要么一个也不分配。 由死锁理论可知，这样就可避免上述死锁情况的发生。为此，在wait操作中，增加了一个“AND”条件，故称为AND同步，或称为同时wait操作， 即</li>
</ul>
</li>
</ul>
<figure class="highlight pascal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Swait(Simultaneous wait)</span><br><span class="line"> Swait(S1, S2, …, Sn)</span><br><span class="line">     <span class="keyword">if</span> S1≥<span class="number">1</span> <span class="keyword">and</span> … <span class="keyword">and</span> Sn≥<span class="number">1</span> <span class="keyword">then</span>   <span class="comment">// 每个资源都可用</span></span><br><span class="line">         <span class="keyword">for</span>  i: =<span class="number">1</span> <span class="keyword">to</span> n <span class="keyword">do</span></span><br><span class="line">                Si:=Si-<span class="number">1</span>; <span class="comment">// 分配所有资源</span></span><br><span class="line">         endfor</span><br><span class="line">     <span class="keyword">else</span>         <span class="comment">//否则，将进程放到等待资源Si的队列中</span></span><br><span class="line">       <span class="comment">//place the process in the waiting queue associated with the first Si found with Si＜1, and set the program count of this process to the beginning of Swait operation</span></span><br><span class="line">     endif</span><br><span class="line"> Ssignal(S1, S2, …, Sn)</span><br><span class="line">       <span class="keyword">for</span>  i:=<span class="number">1</span> <span class="keyword">to</span> n <span class="keyword">do</span></span><br><span class="line">              Si=Si+<span class="number">1</span>;                  <span class="comment">//释放所有资源</span></span><br><span class="line">          <span class="comment">//Remove all the process waiting in the queue associated with Si into the ready queue.</span></span><br><span class="line">       endfor;</span><br></pre></td></tr></table></figure>
<h3 id="信号量集"><a class="markdownIt-Anchor" href="#信号量集"></a> 信号量集</h3>
<ul>
<li>在记录型信号量机制中，wait(S)和signal(S)操作仅能对信号量施以加1或减1操作，意味着每次只能获得或释放一个单位的临界资源，效率较低。</li>
<li>在有些情况下，当<strong>资源数量低于某下限值时便不予分配</strong>。因而，在每次分配之前，都必须测试该资源的数量，看其是否大于等于下限值。</li>
<li>在对AND型信号量机制扩充的基础上，形成一般化的“信号量集”机制。</li>
<li>Swait(S1, t1, d1, …, Sn, tn, dn)</li>
<li>Ssignal(S1, d1, …, Sn, dn)</li>
</ul>
<figure class="highlight pascal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Swait(S1, t1, d1, …, Sn, tn, dn)</span><br><span class="line">    <span class="keyword">if</span> Si≥t1 <span class="keyword">and</span> … <span class="keyword">and</span> Sn≥tn <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">for</span>  i:=<span class="number">1</span> <span class="keyword">to</span> n <span class="keyword">do</span></span><br><span class="line">              Si:=Si-di;          <span class="comment">//一次分配d个资源</span></span><br><span class="line">        endfor</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">              <span class="comment">//Place the executing process in the waiting queue of the first Si</span></span><br><span class="line">             <span class="comment">//with Si＜ti and set its program counter to the beginning of the</span></span><br><span class="line">             <span class="comment">//Swait Operation.</span></span><br><span class="line">    endif</span><br><span class="line">Ssignal(S1, d1, …, Sn, dn)</span><br><span class="line">    <span class="keyword">for</span>  i:=<span class="number">1</span> <span class="keyword">to</span> n <span class="keyword">do</span></span><br><span class="line">          Si :=Si+di; <span class="comment">//释放所有资源</span></span><br><span class="line">	      <span class="comment">//Remove all the process waiting in the queue associated with</span></span><br><span class="line">          <span class="comment">//Si into the ready queue</span></span><br><span class="line">    endfor;</span><br></pre></td></tr></table></figure>
<ul>
<li>一般“信号量集”的几种特殊情况
<ul>
<li>Swait(S, d, d)。 此时在信号量集中只有一个信号量S， 但允许它每次申请d个资源，当现有资源数少于d时，不予分配</li>
<li>Swait(S, 1, 1)。 此时的信号量集已蜕化为一般的记录型信号量(S＞1时)或互斥信号量(S=1时)</li>
<li>Swait(S, 1, 0)。这是一种很特殊且很有用的信号量操作。当S≥1时，允许多个进程进入某特定区；当S变为0后，将阻止任何进程进入特定区。换言之，它相当于一个可控开关</li>
</ul>
</li>
</ul>
<h2 id="信号量的应用"><a class="markdownIt-Anchor" href="#信号量的应用"></a> 信号量的应用</h2>
<h3 id="实现进程互斥"><a class="markdownIt-Anchor" href="#实现进程互斥"></a> 实现进程互斥</h3>
<p>mutex作为互斥锁使用</p>
<figure class="highlight pascal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Var</span> mutex:semaphore:=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">    parbegin</span><br><span class="line">     process <span class="number">1</span>: <span class="keyword">begin</span></span><br><span class="line">           		  <span class="keyword">repeat</span></span><br><span class="line">            		    wait(mutex);</span><br><span class="line">            		    critical section</span><br><span class="line">            		    signal(mutex);</span><br><span class="line">            		    remainder seetion</span><br><span class="line">           		  <span class="keyword">until</span> false;</span><br><span class="line">           		<span class="keyword">end</span></span><br><span class="line">     process <span class="number">2</span>: <span class="keyword">begin</span></span><br><span class="line">	              <span class="keyword">repeat</span></span><br><span class="line">	                    wait(mutex);</span><br><span class="line">	                    critical section</span><br><span class="line">	                    signal(mutex);</span><br><span class="line">	                    remainder section</span><br><span class="line">	               <span class="keyword">until</span> false;</span><br><span class="line">	            <span class="keyword">end</span></span><br><span class="line">    parend</span><br><span class="line">    <span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h3 id="实现前趋关系"><a class="markdownIt-Anchor" href="#实现前趋关系"></a> 实现前趋关系</h3>
<ul>
<li>设有两个并发进程P1和P2。P1中有语句S1，P2中有语句S2，希望在执行完S1后执行S2</li>
<li>为实现这种前趋关系，可让进程P1和P2共享一个公用信号量S，并赋初值为0，将signal(S)操作放在语句S1后面；而在S2语句前插入wait(S)操作</li>
<li>进程P1， S1;signal(S);</li>
<li>进程P2， wait(S); S2;</li>
<li>由于S被初始化为0，若P2先执行，必定阻塞，只有在进程P1执行完使S增为1后，P2才能执行S2操作</li>
</ul>
<h1 id="经典进程的同步问题"><a class="markdownIt-Anchor" href="#经典进程的同步问题"></a> 经典进程的同步问题</h1>
<h2 id="生产者消费者问题"><a class="markdownIt-Anchor" href="#生产者消费者问题"></a> 生产者—消费者问题</h2>
<p>前面我们已经对生产者—消费者问题(The producer-consumer problem)做了一些描述，但未考虑进程的互斥与同步问题，因而造成了数据Counter的不定性。由于生产者—消费者问题是相互合作的进程关系的一种抽象，例如， 在输入时，输入进程是生产者，计算进程是消费者；而在输出时，则计算进程是生产者，而打印进程是消费者， 因此，该问题有很大的代表性及实用价值。<br />
<img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://gitee.com/zoruasama/Zorua-Pic/raw/master/20200504133557.png" alt="" /></p>
<ul>
<li>利用记录型信号量解决生产者—消费者问题
<ul>
<li>假定在生产者和消费者之间的公用缓冲池中，具有n个缓冲区</li>
<li>考虑哪些是互斥资源、哪些是资源信号量？
<ul>
<li><strong>互斥资源</strong>——缓冲区、计数器，设互斥信号量mutex实现诸进程对缓冲池的互斥使用及计数器的加减操作</li>
<li><strong>资源信号量</strong>——缓冲池，设信号量empty和full分别表示缓冲池中空缓冲区和满缓冲区的数量。</li>
</ul>
</li>
<li>假定这些生产者和消费者相互等效，只要缓冲池未满，生产者便可将消息送入缓冲池；只要缓冲池未空，消费者便可从缓冲池中取走一个消息</li>
</ul>
</li>
</ul>
<figure class="highlight pascal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Var</span> mutex, empty, full:semaphore:=<span class="number">1</span>,n,<span class="number">0</span>;</span><br><span class="line">        buffer:<span class="keyword">array</span>［<span class="number">0</span>, …, n-<span class="number">1</span>］ <span class="keyword">of</span> item;</span><br><span class="line">        <span class="keyword">in</span>, <span class="keyword">out</span>: integer:=<span class="number">0</span>, <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">     parbegin</span><br><span class="line">      producer:<span class="keyword">begin</span><span class="comment">//生产者进程</span></span><br><span class="line">            <span class="keyword">repeat</span></span><br><span class="line">             …</span><br><span class="line">            produce an item nextp; <span class="comment">//产一个产品</span></span><br><span class="line">             …</span><br><span class="line">            wait(empty); <span class="comment">//empty减1</span></span><br><span class="line">            wait(mutex);<span class="comment">//加锁</span></span><br><span class="line">            buffer(<span class="keyword">in</span>):=nextp;</span><br><span class="line">            <span class="keyword">in</span>:=(<span class="keyword">in</span>+<span class="number">1</span>) <span class="keyword">mod</span> n;  <span class="comment">//移动生产指针</span></span><br><span class="line">            signal(mutex);<span class="comment">//解锁</span></span><br><span class="line">            signal(full); <span class="comment">//full增1</span></span><br><span class="line">            <span class="keyword">until</span> false;</span><br><span class="line">       <span class="keyword">end</span></span><br><span class="line">      consumer:<span class="keyword">begin</span> <span class="comment">//消费者进程</span></span><br><span class="line">            <span class="keyword">repeat</span></span><br><span class="line">            wait(full);</span><br><span class="line">            wait(mutex);</span><br><span class="line">            nextc:=buffer(<span class="keyword">out</span>);</span><br><span class="line">            <span class="keyword">out</span>:= (<span class="keyword">out</span>+<span class="number">1</span>) <span class="keyword">mod</span> n;</span><br><span class="line">            signal(mutex);</span><br><span class="line">            signal(empty);</span><br><span class="line">            consume the item <span class="keyword">in</span> nextc;</span><br><span class="line">            <span class="keyword">until</span> false;</span><br><span class="line">       <span class="keyword">end</span></span><br><span class="line">      parend</span><br><span class="line">    <span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<ul>
<li>在生产者—消费者问题中要注意以下几点
<ul>
<li>在每个程序中用于实现互斥的wait(mutex)和signal(mutex)必须<strong>成对地出现</strong>；</li>
<li>对资源信号量empty和full的wait和signal操作，同样需要成对地出现，但它们分别处于不同的进程中。例如，wait(empty)在生产进程中，而signal(empty)则在消费进程中，生产进程若因执行wait(empty)而阻塞， 则以后将由消费进程将它唤醒；</li>
<li>在每个程序中的多个wait<strong>操作顺序不能颠倒</strong>。应先执行对资源信号量的wait操作，然后再执行对互斥信号量的wait操作，否则可能引起进程死锁</li>
</ul>
</li>
</ul>
<h3 id="利用and信号量解决生产者消费者问题"><a class="markdownIt-Anchor" href="#利用and信号量解决生产者消费者问题"></a> 利用AND信号量解决生产者—消费者问题</h3>
<figure class="highlight pascal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mutex, empty, full:semaphore: =<span class="number">1</span>, n, <span class="number">0</span>;</span><br><span class="line">    buffer:<span class="keyword">array</span>［<span class="number">0</span>, …, n-<span class="number">1</span>］ <span class="keyword">of</span> item;</span><br><span class="line">    <span class="keyword">in</span> <span class="keyword">out</span>:integer : =<span class="number">0</span>, <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">begin</span></span><br><span class="line">    parbegin</span><br><span class="line">      producer:<span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">repeat</span></span><br><span class="line">             …</span><br><span class="line">            produce an item <span class="keyword">in</span> nextp;</span><br><span class="line">             …</span><br><span class="line">            Swait(empty, mutex);</span><br><span class="line">            buffer(<span class="keyword">in</span>): =nextp;</span><br><span class="line">            <span class="keyword">in</span>: = (<span class="keyword">in</span>+<span class="number">1</span>)<span class="keyword">mod</span> n;</span><br><span class="line">            Ssignal(mutex, full);</span><br><span class="line">           <span class="keyword">until</span> false;</span><br><span class="line">         <span class="keyword">end</span></span><br><span class="line">      consumer:<span class="keyword">begin</span></span><br><span class="line">             <span class="keyword">repeat</span></span><br><span class="line">             Swait(full, mutex);</span><br><span class="line">             nextc:=buffer(<span class="keyword">out</span>);</span><br><span class="line">             <span class="keyword">out</span>:= (<span class="keyword">out</span>+<span class="number">1</span>) <span class="keyword">mod</span> n;</span><br><span class="line">             Ssignal(mutex, empty);</span><br><span class="line">             consumer the item <span class="keyword">in</span> nextc;</span><br><span class="line">             <span class="keyword">until</span> false;</span><br><span class="line">           <span class="keyword">end</span></span><br><span class="line">         parend</span><br><span class="line">   <span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h2 id="哲学家进餐问题"><a class="markdownIt-Anchor" href="#哲学家进餐问题"></a> 哲学家进餐问题</h2>
<ul>
<li>
<p>哲学家进餐问题（The Dinning Philosophers Problem）是由Dijkstra提出并解决的典型进程同步问题</p>
</li>
<li>
<p>问题描述</p>
<ul>
<li>5个哲学家坐在桌子边，桌上有5个碗和5支筷子</li>
<li>哲家家的生活方式是交替地进行思考和进餐</li>
<li>哲学家饥饿时便拿起两边的筷子进餐，但只有当拿到两支后才能进餐</li>
<li>用餐毕，放下筷子继续思考<br />
<img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://gitee.com/zoruasama/Zorua-Pic/raw/master/20200504134706.png" alt="" /></li>
</ul>
</li>
<li>
<p>利用记录型信号量解决哲学家进餐问题</p>
</li>
<li>
<p>经分析可知，放在桌子上的筷子是临界资源，在一段时间内只允许一位哲学家使用。</p>
</li>
<li>
<p>为了实现对筷子的互斥使用，可以用一个信号量表示一只筷子，由这五个信号量构成信号量数组。其描述如下：</p>
</li>
</ul>
<figure class="highlight pascal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Var</span> chopstick: <span class="keyword">array</span>［<span class="number">0</span>, …, <span class="number">4</span>］ <span class="keyword">of</span> semaphore;</span><br></pre></td></tr></table></figure>
<p>所有信号量均被初始化为1， 第i位哲学家的活动可描述为：</p>
<figure class="highlight pascal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">repeat</span></span><br><span class="line">    wait(chopstick［i］);</span><br><span class="line">    wait(chopstick［(i+<span class="number">1</span>) <span class="keyword">mod</span> <span class="number">5</span>］);</span><br><span class="line">     …</span><br><span class="line">    eat;</span><br><span class="line">     …</span><br><span class="line">    signal(chopstick［i］);</span><br><span class="line">    signal(chopstick［(i+<span class="number">1</span>) <span class="keyword">mod</span> <span class="number">5</span>］);</span><br><span class="line">    …</span><br><span class="line">    think;</span><br><span class="line"><span class="keyword">until</span> false;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>问题：同时拿起一侧的筷子，则——死锁，如何解决？？？</p>
</blockquote>
<ul>
<li>可采取以下几种解决方法
<ul>
<li>至多<strong>只允许有四位哲学家</strong>同时去<strong>拿左边</strong>的筷子，最终能保证至少有一位哲学家能够进餐，并在用毕时能释放出他用过的两只筷子，从而使更多的哲学家能够进餐</li>
<li>仅当哲学家的<strong>左、右两只筷子</strong>均可用时，才允许他拿起筷子进餐</li>
<li>规定奇数号哲学家先拿他左边的筷子，然后再去拿右边的筷子；而偶数号哲学家则相反。按此规定，将是1、 2号哲学家竞争1号筷子；3、4号哲学家竞争3号筷子。即五位哲学家都<strong>先竞争奇数号筷子</strong>，获得后，再去<strong>竞争偶数号筷子</strong>，最后总会有一位哲学家能获得两只筷子而进餐<br />
利用AND信号量机制解决哲学家进餐问题<br />
在哲学家进餐问题中，要求每个哲学家先获得两个临界资源(筷子)后方能进餐，这在本质上就是前面所介绍的AND同步问题，故用AND信号量机制可获得最简洁的解法</li>
</ul>
</li>
</ul>
<figure class="highlight pascal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Var</span> chopstick <span class="keyword">array</span> ［<span class="number">0</span>, …, <span class="number">4</span>］ <span class="keyword">of</span> semaphore:= (<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">    processi</span><br><span class="line">        <span class="keyword">repeat</span></span><br><span class="line">           think;</span><br><span class="line">           Sswait(chopstick［(i+<span class="number">1</span>) <span class="keyword">mod</span> <span class="number">5</span>］, chopstick ［i］);</span><br><span class="line">           eat;</span><br><span class="line">           Ssignat(chopstick ［(i+<span class="number">1</span>) <span class="keyword">mod</span> <span class="number">5</span>］, chopstick ［i］);</span><br><span class="line">      <span class="keyword">until</span> false;</span><br></pre></td></tr></table></figure>
<h2 id="读者写者问题"><a class="markdownIt-Anchor" href="#读者写者问题"></a> 读者—写者问题</h2>
<ul>
<li>一个数据文件或记录可被多个进程共享，我们把只要求读该文件的进程称为“Reader进程”，其他进程称为“Writer进程”</li>
<li><strong>允许多个进程同时读一个共享对象</strong>，因为读不会使数据文件混乱</li>
<li><strong>不允许一个Writer进程和其他Reader进程或Writer进程同时访问一个对象</strong></li>
<li>读者—写者问题(Reader-Writer Problem)是指保证一个Writer进程必须与其他进程互斥地访问共享对象的同步问题</li>
<li>读者—写者问题常被用来测试新同步原语</li>
</ul>
<hr />
<ul>
<li>利用记录型信号量解决读者-写者问题思想</li>
<li>为实现Reader与Writer进程间在读或写时的互斥而设置了一个互斥信号量Wmutex。另外，再设置一个整型变量Readcount表示正在读的进程数目</li>
<li>由于只要有一个Reader进程在读，便不允许Writer进程去写。因此，仅当Readcount=0, 表示尚无Reader进程在读时，Reader进程才需要执行wait(Wmutex)操作</li>
<li>若wait(Wmutex)操作成功，Reader进程便可去读，相应地，做Readcount+1操作。同理，仅当Reader进程在执行了Readcount减1操作后其值为0时，才须执行signal(Wmutex)操作，以便让Writer进程写</li>
<li>又因为Readcount是一个可被多个Reader进程访问的临界资源，因此，应该为它设置一个计数器互斥信号量rmutex</li>
</ul>
<hr />
<p>读者-写者问题可描述如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">Var rmutex, wmutex:semaphore:&#x3D;1,1;</span><br><span class="line">       Readcount:integer:&#x3D;0;</span><br><span class="line">begin</span><br><span class="line">   parbegin</span><br><span class="line">     Reader:begin</span><br><span class="line">        repeat</span><br><span class="line">         wait(rmutex);</span><br><span class="line">         if readcount&#x3D;0 then wait(wmutex);</span><br><span class="line">          Readcount :&#x3D;Readcount+1;</span><br><span class="line">           …</span><br><span class="line">         signal(rmutex);</span><br><span class="line">           …</span><br><span class="line">         perform read operation;</span><br><span class="line">           …</span><br><span class="line">         wait(rmutex);</span><br><span class="line">         readcount:&#x3D;readcount-1;</span><br><span class="line">         if readcount&#x3D;0 then</span><br><span class="line">                signal(wmutex);</span><br><span class="line">         signal(rmutex);</span><br><span class="line">        until false;</span><br><span class="line">     end</span><br><span class="line">     writer:begin</span><br><span class="line">        repeat</span><br><span class="line">         wait(wmutex);</span><br><span class="line">         perform write operation;</span><br><span class="line">         signal(wmutex);</span><br><span class="line">        until false;</span><br><span class="line">       end</span><br><span class="line">     end</span><br><span class="line">   parend</span><br></pre></td></tr></table></figure>
<h3 id="利用信号量集机制解决读者-写者问题"><a class="markdownIt-Anchor" href="#利用信号量集机制解决读者-写者问题"></a> 利用信号量集机制解决读者-写者问题</h3>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Var RN integer;&#x2F;&#x2F;允许有RN个读者同时读</span><br><span class="line">    L, mx:semaphore:&#x3D;RN,1;</span><br><span class="line">begin</span><br><span class="line">    parbegin</span><br><span class="line">     reader:begin</span><br><span class="line">        repeat</span><br><span class="line">           Swait(L,1,1);</span><br><span class="line">           Swait(mx,1,0);           &#x2F;&#x2F;只要mx有资源，即可增加</span><br><span class="line">           …</span><br><span class="line">           perform read operation;</span><br><span class="line">           …</span><br><span class="line">           Ssignal(L,1);</span><br><span class="line">        until false;</span><br><span class="line">     end</span><br><span class="line">     writer:begin</span><br><span class="line">        repeat</span><br><span class="line">           Swait(mx,1,1; L,RN,0);  &#x2F;&#x2F;既无writer进程在写(mx&#x3D;1)，又无reader进程在读(L&#x3D;RN)</span><br><span class="line">           perform write operation;</span><br><span class="line">           Ssignal(mx,1);</span><br><span class="line">        until false;</span><br><span class="line">     end</span><br><span class="line">    parend</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<h2 id="独木桥问题"><a class="markdownIt-Anchor" href="#独木桥问题"></a> 独木桥问题</h2>
<p>独木桥问题（仅允许一人通过）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Var mx:semaphore:&#x3D;1;</span><br><span class="line">begin</span><br><span class="line">    parbegin</span><br><span class="line">     man(i):begin</span><br><span class="line">         wait(mx);</span><br><span class="line">         过桥；</span><br><span class="line">         signal(mx);</span><br><span class="line">     end</span><br><span class="line">     parend</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<h1 id="管程机制"><a class="markdownIt-Anchor" href="#管程机制"></a> 管程机制</h1>
<h2 id="管程的引入"><a class="markdownIt-Anchor" href="#管程的引入"></a> 管程的引入</h2>
<p>引入信号量机制，在使用同步操作wait(S)和signal(S)(P、V操作)时，也会造成错误。</p>
<ol>
<li>错误1：颠倒</li>
</ol>
<figure class="highlight pascal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">signal(mutex);</span><br><span class="line">critical section</span><br><span class="line">wait(mutex);</span><br></pre></td></tr></table></figure>
<p>这种情况可能会造成几个进程同时进入临界区。<br />
2. 错误2：误写</p>
<figure class="highlight pascal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wait(mutex);</span><br><span class="line">critical section</span><br><span class="line">wait(mutex);</span><br></pre></td></tr></table></figure>
<p>两次执行P操作使mutex变成-1，这样，任何进程都进不了临界区，从而也不会再有V操作去唤醒出错的进程，造成死锁。<br />
3. 错误3：遗漏1</p>
<figure class="highlight pascal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">critical section</span><br><span class="line">signal(mutex);</span><br></pre></td></tr></table></figure>
<p>会使多个进程进入临界区。</p>
<ol start="4">
<li>错误3：遗漏2</li>
</ol>
<figure class="highlight pascal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wait(mutex);</span><br><span class="line">critical section</span><br></pre></td></tr></table></figure>
<p>其他进程无法进入临界区，也不能唤醒因不能进入临界区而阻塞的进程。</p>
<p>基于上述情况，Dijkstra于1971年提出，把所有进程对某一种临界资源的同步操作都集中起来，构成一个所谓的“秘书”进程。凡是要访问该临界资源的进程，都需先报告“秘书”，由秘书来实现诸进程的同步。<br />
1973年，Hansan和Hoare又把“秘书”进程思想发展为管程概念；把并发进程间的同步操作，分别集中于相应的管程中。</p>
<h2 id="管程的基本概念"><a class="markdownIt-Anchor" href="#管程的基本概念"></a> 管程的基本概念</h2>
<ul>
<li>管程的提出
<ul>
<li>虽然信号量机制是一种既方便又有效的进程同步机制，但每个要访问临界资源的进程都必须自备同步操作wait(S)和signal(S)。这就使大量的同步操作分散在各个进程中。给系统的管理带来麻烦，也可能因同步操作不当而导致死锁</li>
</ul>
</li>
<li>管程(Monitors)的定义
<ul>
<li>一个<strong>管程</strong>定义了一个<strong>数据结构</strong>和能为并发进程所执行的<strong>一组操作</strong>，这组操作能同步进程和改变管程中的数据 (by Hansan)</li>
<li>管程由三部分组成
<ul>
<li>局部于管程的共享变量说明；</li>
<li>对该数据结构进行操作的一组过程；</li>
<li>对局部于管程的数据设置初始值的语句</li>
</ul>
</li>
<li>管程还必须有一个名字</li>
</ul>
</li>
<li>局部于管程的数据结构，仅能被局部于管程的过程所访问；</li>
<li>局部于管程的过程也仅能访问管程内的数据结构</li>
<li>管程相当于围墙，把共享变量和对它操作的过程围起来，而每次只允许一个进程进入，从而实现了互斥操作<br />
<img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://gitee.com/zoruasama/Zorua-Pic/raw/master/20200504225539.png" alt="管程示意图" /></li>
</ul>
<h3 id="管程的语法"><a class="markdownIt-Anchor" href="#管程的语法"></a> 管程的语法</h3>
<figure class="highlight pascal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> monitor-<span class="keyword">name</span>=monitor</span><br><span class="line">          variable declarations</span><br><span class="line">          <span class="function"><span class="keyword">procedure</span> <span class="title">entry</span> <span class="title">P1</span><span class="params">(…)</span></span></span><br><span class="line"><span class="function">               <span class="title">begin</span> … <span class="title">end</span>;</span></span><br><span class="line">          <span class="function"><span class="keyword">procedure</span> <span class="title">entry</span> <span class="title">P2</span><span class="params">(…)</span></span></span><br><span class="line"><span class="function">              <span class="title">begin</span> … <span class="title">end</span>;</span></span><br><span class="line">              …</span><br><span class="line">          <span class="function"><span class="keyword">procedure</span> <span class="title">entry</span> <span class="title">Pn</span><span class="params">(…)</span></span></span><br><span class="line"><span class="function">              <span class="title">begin</span> … <span class="title">end</span>;</span></span><br><span class="line">         <span class="keyword">begin</span></span><br><span class="line">              <span class="keyword">initialization</span> code;</span><br><span class="line">         <span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<ul>
<li>在实现一个管程时，必须考虑：
<ul>
<li>互斥。通常编译程序对每个管程自动产生一个互斥信号量（初值为1）。每次只准许一个进程进入管程，其他调用管程者必须等待。</li>
<li>同步。设置两个同步原语wait和signal.</li>
</ul>
</li>
<li>当某进程通过管程请求临界资源而不能满足时，管程便调用wait原语使该进程等待，并将它排在（管程）的等待队列上。</li>
<li>当另一进程访问完并释放之后，管程又调用signal原语，唤醒等待队列中的队首进程。</li>
</ul>
<h4 id="条件变量"><a class="markdownIt-Anchor" href="#条件变量"></a> 条件变量</h4>
<ul>
<li>管程中对每个条件变量，都须予以说明，其形式为：<strong>Var x, y:condition</strong>。该变量应置于wait和signal之前，即可表示为X.wait和X.signal。例如，由于共享数据被占用而使调用进程等待，该条件变量的形式为：<strong>nonbusy:condition</strong>。此时， wait原语应改为nonbusy.wait，相应地，signal应改为<strong>nonbusy.signal</strong></li>
<li>应当指出，X.signal操作的作用，是重新启动一个被阻塞的进程，但如果没有被阻塞的进程，则X.signal操作不产生任何后果。这与信号量机制中的signal操作不同。因为，后者总是要执行s∶=s+1操作，因而总会改变信号量的状态</li>
<li>如果有进程Q处于阻塞状态， 当进程P执行了X.signal操作后，怎样决定由哪个进行执行，哪个等待，可采用下述两种方式之一进行处理：
<ul>
<li>P等待，直至Q离开管程或等待另一条件。</li>
<li>Q等待，直至P离开管程或等待另一条件。</li>
<li>采用哪种处理方式， 当然是各执一词。 但是Hansan采用了第一种处理方式</li>
</ul>
</li>
</ul>
<h2 id="利用管程解决生产者消费者问题"><a class="markdownIt-Anchor" href="#利用管程解决生产者消费者问题"></a> 利用管程解决生产者—消费者问题</h2>
<ul>
<li>在利用管程方法来解决生产者-消费者问题时， 首先便是为它们建立一个管程，并命名为Producer-Consumer, 或简称为PC。其中包括两个过程
<ul>
<li>put(item)过程。生产者利用该过程将自己生产的产品投放到缓冲池中，并用整型变量count来表示在缓冲池中已有的产品数目，当count≥n时， 表示缓冲池已满， 生产者须等待。</li>
<li>get(item)过程。消费者利用该过程从缓冲池中取出一个产品，当count≤0时，表示缓冲池中已无可取用的产品， 消费者应等待。<br />
PC管程可描述如下：</li>
</ul>
</li>
</ul>
<figure class="highlight pascal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> producer-consumer=monitor</span><br><span class="line">    <span class="keyword">Var</span> <span class="keyword">in</span>,<span class="keyword">out</span>,count:integer;</span><br><span class="line">     buffer:<span class="keyword">array</span>［<span class="number">0</span>,…,n-<span class="number">1</span>］ <span class="keyword">of</span> item;</span><br><span class="line">     notfull, notempty:condition;</span><br><span class="line">     <span class="function"><span class="keyword">procedure</span> <span class="title">entry</span> <span class="title">put</span><span class="params">(item)</span></span></span><br><span class="line"><span class="function">       <span class="title">begin</span></span></span><br><span class="line"><span class="function">        <span class="title">if</span> <span class="title">count</span>≥<span class="title">n</span> <span class="title">then</span> <span class="title">notfull</span>.<span class="title">wait</span>;</span>   <span class="comment">//缓冲区满等待</span></span><br><span class="line">         buffer(<span class="keyword">in</span>):=nextp;</span><br><span class="line">         <span class="keyword">in</span>:=(<span class="keyword">in</span>+<span class="number">1</span>) <span class="keyword">mod</span> n;</span><br><span class="line">         count:=count+<span class="number">1</span>;</span><br><span class="line">         <span class="keyword">if</span> notempty.queue <span class="keyword">then</span></span><br><span class="line">            notempty.signal;  <span class="comment">//重新启动一个因缓冲区空而被阻塞的过程</span></span><br><span class="line">       <span class="keyword">end</span></span><br><span class="line">     <span class="function"><span class="keyword">procedure</span> <span class="title">entry</span> <span class="title">get</span><span class="params">(item)</span></span></span><br><span class="line"><span class="function">       <span class="title">begin</span></span></span><br><span class="line"><span class="function">         <span class="title">if</span> <span class="title">count</span>≤0 <span class="title">then</span> <span class="title">notempty</span>.<span class="title">wait</span>;</span> <span class="comment">//缓冲区空等待</span></span><br><span class="line">         nextc:=buffer(<span class="keyword">out</span>);</span><br><span class="line">         <span class="keyword">out</span>:= (<span class="keyword">out</span>+<span class="number">1</span>) <span class="keyword">mod</span> n;</span><br><span class="line">         count:=count-<span class="number">1</span>;</span><br><span class="line">         <span class="keyword">if</span> notfull.queue <span class="keyword">then</span></span><br><span class="line">            notfull.signal;    <span class="comment">//重新启动一个因缓冲区满而被阻塞的过程</span></span><br><span class="line">       <span class="keyword">end</span></span><br><span class="line"> <span class="keyword">begin</span></span><br><span class="line">         <span class="keyword">in</span>:=<span class="keyword">out</span>:=<span class="number">0</span>;</span><br><span class="line">         count:=<span class="number">0</span>;</span><br><span class="line"> <span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>在利用管程解决生产者-消费者问题时， 其中的生产者和消费者可描述为</p>
<figure class="highlight pascal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">producer:<span class="keyword">begin</span></span><br><span class="line">      <span class="keyword">repeat</span></span><br><span class="line">           produce an item <span class="keyword">in</span> nextp;</span><br><span class="line">           PC.put(item);</span><br><span class="line">      <span class="keyword">until</span> false;</span><br><span class="line">         <span class="keyword">end</span></span><br><span class="line">consumer:<span class="keyword">begin</span></span><br><span class="line">      <span class="keyword">repeat</span></span><br><span class="line">           PC.get(item);</span><br><span class="line">           consume the item <span class="keyword">in</span> nextc;</span><br><span class="line">      <span class="keyword">until</span> false;</span><br><span class="line">         <span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h1 id="进程通信"><a class="markdownIt-Anchor" href="#进程通信"></a> 进程通信</h1>
<p>信号量机制就是一种进程通信方式。但是——</p>
<ol>
<li>交换的信息量比较少；</li>
<li>效率低；</li>
<li>对用户不透明。</li>
</ol>
<h2 id="进程通信的类型"><a class="markdownIt-Anchor" href="#进程通信的类型"></a> 进程通信的类型</h2>
<ul>
<li>进程通信：为协调完成某一任务，几个进程间应保持联系，即交换一定数量的信息。</li>
<li>低级通信：仅交换少量的数据和一些状态，如前述的同步与互斥方式。（P、V操作）
<ol>
<li>效率低</li>
<li>通信对用户不透明</li>
</ol>
</li>
<li>高级通信：交换信息量大，用户可直接利用OS提供的通信命令高效的传送大量数据。（OS隐去了实现细节，对用户是透明的。）
<ol>
<li>共享存储器系统</li>
<li>消息传递系统</li>
<li>管道通信系统</li>
</ol>
</li>
</ul>
<h3 id="共享存储器系统shared-memory-system"><a class="markdownIt-Anchor" href="#共享存储器系统shared-memory-system"></a> 共享存储器系统(Shared-Memory System)</h3>
<ul>
<li>基于共享数据结构的通信方式
<ul>
<li>要求诸进程共享某些数据结构，借以实现进程间的数据交换。如生产者—消费者问题中，用有界缓冲区来实现通信</li>
<li>对用户<strong>不透明</strong>，程序员负担重，操作系统效率低，只<strong>适合传递少量数据</strong>，属于<strong>低级通信方式</strong></li>
</ul>
</li>
<li>基于共享存储区的通信方式
<ul>
<li>在存储器中划出一块共享存储区，诸进程可通过对共享存储区中的数据读写来实现通信</li>
<li>属于高级通信，<strong>适合传送大量数据</strong></li>
</ul>
</li>
</ul>
<h3 id="消息传递系统message-passing-system"><a class="markdownIt-Anchor" href="#消息传递系统message-passing-system"></a> 消息传递系统(Message passing system)</h3>
<ul>
<li>进程之间的数据交换，是以格式化的消息(message)为单位的；在计算机网络中，又把message称为<strong>报文</strong></li>
<li>实现方式：程序员直接利用系统提供的一组<strong>通信命令</strong>(原语)进行通信。</li>
<li>消息传递系统的通信方式属于高级通信方式。可分为<strong>直接通信方式和间接通信方式</strong></li>
<li>优点：传递信息量大、对用户透明、应用广泛</li>
<li>广泛应用于单机系统、多机系统、计算机网络</li>
<li>直接通信方式
<ul>
<li>发送进程直接将消息发送给接收进程，并将消息挂在接收进程</li>
<li>的消息队列上，接收进程从消息队列中取得消息。</li>
</ul>
</li>
<li>间接通信方式
<ul>
<li>发送进程发送消息到“信箱”中，接收进程从“信箱”中取得消息，</li>
<li>相应的系统称为电子邮件系统。</li>
</ul>
</li>
</ul>
<h3 id="管道pipe通信共享文件方式"><a class="markdownIt-Anchor" href="#管道pipe通信共享文件方式"></a> 管道(Pipe)通信（共享文件方式）</h3>
<ul>
<li>管道是指用于连接一个读进程和一个写进程以实现他们之间通信的一个共享文件，又名pipe文件</li>
<li>向<strong>管道</strong>(共享文件)提供输入的<strong>发送进程</strong>(即写进程)， 以字符流形式将大量的数据送入管道；而接受管道输出的<strong>接收进程</strong>(即读进程)，则从管道中接收(读)数据</li>
<li>由于发送进程和接收进程是利用管道进行通信的，故又称为<strong>管道通信</strong></li>
<li>这种方式首创于UNIX系统，由于它能有效地传送大量数据，因而又被引入到许多其它操作系统中</li>
<li>管道的作用类似于消息缓冲区（生产-消费），但有显著不同特点：
<ol>
<li><strong>以文件为传输介质</strong>，可传输大量数据。</li>
<li><strong>以字符流方式读写</strong>，不必以消息为单位。</li>
<li><strong>以队列方式工作</strong>，先写入的先读出。</li>
</ol>
</li>
<li>管道机制必须提供以下三方面的协调能力
<ul>
<li><strong>互斥</strong>，即当一个进程正在对pipe执行读/写操作时，其它(另一)进程必须等待</li>
<li><strong>同步</strong>，指当写(输入)进程把一定数量(如4 KB)的数据写入pipe，便去睡眠等待，直到读(输出)进程取走数据后，再把他唤醒。当读进程读一空pipe时，也应睡眠等待，直至写进程将数据写入管道后，才将之唤醒</li>
<li><strong>确定对方是否存在</strong>，只有确定了对方已存在时，才能进行通信</li>
</ul>
</li>
</ul>
<h2 id="消息传递通信的实现方法"><a class="markdownIt-Anchor" href="#消息传递通信的实现方法"></a> 消息传递通信的实现方法</h2>
<h3 id="直接通信方式"><a class="markdownIt-Anchor" href="#直接通信方式"></a> 直接通信方式</h3>
<ul>
<li><strong>发送进程</strong>利用OS所提供的发送命令，<strong>直接</strong>把消息发送给<strong>目标进程</strong>。</li>
<li>系统提供通信命令(原语)：
<ul>
<li>Send(Receiver, message); 发送一个消息给接收进程；</li>
<li>Receive(Sender, message); 接收Sender发来的消息；</li>
</ul>
</li>
<li>要求发送进程和接收进程：
<ul>
<li>一对一：都以<strong>显式方式</strong>提供对方的标识符。
<ul>
<li>Send(P1, m1)；</li>
<li>Receive(P2, m1)；</li>
</ul>
</li>
<li><strong>不可能</strong>事先<strong>指定发送进程</strong>：接收进程可与多个发送进程通信。例如，用于提供打印服务的进程，它可以接收来自任何一个进程的“打印请求”消息。对于这样的应用，在接收进程接收消息的原语中的源进程参数，是完成通信后的返回值，接收原语可表示为：
<ul>
<li>Receive (id, message);</li>
</ul>
</li>
</ul>
</li>
<li>利用直接通信原语解决生产者-消费者问题。生产者用Send原语将消息发送给消费者进程；消费者进程用Receive原语来得到一个消息。若消息尚未生产出来，消费者必须等待，直至生产者进程将消息发送过来。</li>
</ul>
<figure class="highlight pascal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> Producer: <span class="keyword">repeat</span></span><br><span class="line">              produce an item <span class="keyword">in</span> nextp;</span><br><span class="line">              send(consumer, nextp);</span><br><span class="line">          <span class="keyword">until</span> false;</span><br><span class="line">Consumer: <span class="keyword">repeat</span></span><br><span class="line">              receive(producer, nextc);</span><br><span class="line">              consume the item <span class="keyword">in</span> nextc;</span><br><span class="line">          <span class="keyword">until</span> false;</span><br></pre></td></tr></table></figure>
<h3 id="间接通信方式"><a class="markdownIt-Anchor" href="#间接通信方式"></a> 间接通信方式</h3>
<ul>
<li>通过作为共享数据结构的实体——信箱，进行通信</li>
<li>系统提供信箱通信原语
<ul>
<li>创建：建立一个新信箱，给出信箱名字、信箱属性(公用、私用或共享)。共享信箱， 还应给出共享者的名字</li>
<li>撤消：不再需要信箱时，可用撤消原语将之撤消</li>
<li>消息的发送和接收。当进程之间要利用信箱进行通信时，必须使用共享信箱，通信原语
<ul>
<li>Send(mailbox, message); 将一个消息发送到指定信箱；</li>
<li>Receive(mailbox, message); 从指定信箱中接收一个消息</li>
</ul>
</li>
</ul>
</li>
<li>信箱可由操作系统创建，也可由用户进程创建，创建者是信箱的拥有者。据此，可把信箱分为以下三类
<ul>
<li><strong>私用信箱</strong>——用户进程可为自己建立一个新信箱，并作为该进程的一部分。信箱的拥有者有权从信箱中读取消息，其他用户则只能将自己构成的消息发送到该信箱中。这种私用信箱可采用<strong>单向通信链路</strong>的信箱来实现。当拥有该信箱的进程结束时，信箱也随之消失</li>
<li><strong>公用信箱</strong>——它由操作系统创建，并提供给系统中的所有核准进程使用。核准进程既可把消息发送到该信箱中，也可从信箱中读取发送给自己的消息。显然，公用信箱应采用<strong>双向通信链路</strong>的信箱来实现。通常，公用信箱在系统运行期间始终存在</li>
<li><strong>共享信箱</strong>——它由某进程创建，在创建时或创建后，指明它是可共享的，同时须指出共享进程(用户)的名字。信箱的拥有者和共享者，都有权从信箱中取走发送给自己的消息</li>
</ul>
</li>
<li>在利用信箱通信时，在发送进程和接收进程之间，存在以下四种关系：
<ul>
<li>一对一关系。这时可为发送进程和接收进程建立一条两者<strong>专用的通信链路</strong>，使两者之间的交互不受其他进程的干扰</li>
<li>多对一关系。允许提供服务的进程与多个用户进程之间进行交互，也称为<strong>客户/服务器交互</strong>(client/server interaction)</li>
<li>一对多关系。允许一个发送进程与多个接收进程进行交互，使发送进程可用<strong>广播方式</strong>，向接收者(多个)发送消息</li>
<li>多对多关系。允许建立一个<strong>公用信箱</strong>，让多个进程都能向信箱中投递消息；也可从信箱中取走属于自己的消息</li>
</ul>
</li>
</ul>
<h2 id="消息传递系统实现中的若干问题"><a class="markdownIt-Anchor" href="#消息传递系统实现中的若干问题"></a> 消息传递系统实现中的若干问题</h2>
<h3 id="通信链路communication-link"><a class="markdownIt-Anchor" href="#通信链路communication-link"></a> 通信链路(communication link)</h3>
<ul>
<li>要在发送进程和接收进程之间能进行通信，必须在两者之间建立一条<strong>通信链路</strong>。两种方式：
<ul>
<li>显式的“<strong>建立连接</strong>” 和拆除链路。用命令(原语)请求系统做。这种方式主要用于<strong>计算机网络</strong>中</li>
<li>系统自动地建立一条链路。无须明确提出建立链路的请求，只须利用系统提供的<strong>发送命令</strong>(原语)。这种方式主要用于<strong>单机</strong>系统中</li>
</ul>
</li>
<li>根据通信链路的连接方法，可把通信链路分为
<ul>
<li><strong>点—点连接通信链路</strong>，这时的一条链路只连接两个结点(进程)；</li>
<li><strong>多点连接链路</strong>，指用一条链路连接多个(n＞2)结点(进程)</li>
</ul>
</li>
<li>根据通信方式，可把链路分成
<ul>
<li><strong>单向通信链路</strong>，只允许发送进程向接收进程发送消息；</li>
<li><strong>双向链路</strong>，既允许由进程A向进程B发送消息，也允许进程B同时向进程A发送消息</li>
</ul>
</li>
<li>还可根据通信链路容量的不同而把链路分成两类：
<ul>
<li>无容量通信链路，在这种通信连路上没有缓冲区，因而不能暂存任何消息；</li>
<li>有容量通信链路，指在通信链路中设置了缓冲区，因而能暂存消息。缓冲区数目愈多，通信链路的容量愈大。</li>
</ul>
</li>
</ul>
<h3 id="消息的格式"><a class="markdownIt-Anchor" href="#消息的格式"></a> 消息的格式</h3>
<ul>
<li>定长消息格式：消息比较短
<ul>
<li>优点：减少了对消息的处理和存储开销。</li>
<li>缺点：对要发送较长消息的用户是不方便的</li>
<li>这种方式可用于办公自动化系统中，为用户提供快速的便笺式通信；</li>
</ul>
</li>
<li>变长的消息格式：消息的长度是可变的。
<ul>
<li>优点：方便了用户</li>
<li>缺点：处理和存储变长消息，须付出更多开销</li>
</ul>
</li>
<li>两种消息格式各有其优缺点，故在很多系统(包括计算机网络)中，是同时都用的</li>
</ul>
<h3 id="进程同步方式"><a class="markdownIt-Anchor" href="#进程同步方式"></a> 进程同步方式</h3>
<ul>
<li>辅以进程同步机制，使诸进程能协调通信。不论是发送还是接收进程，在完成消息的发送或接收后有两种可能，继续发送（接收）或阻塞
<ul>
<li><strong>发送进程阻塞、接收进程阻塞</strong> ——主要用于进程之间紧密同步（tight synchronization），发送进程和接收进程之间无缓冲时。这两个进程平时都处于阻塞状态，直到有消息传递时。这种方式称为<strong>汇合</strong>（rendezrous）</li>
<li><strong>发送进程不阻塞、接收进程阻塞</strong>——这是应用最多的一种进程同步方式。发送进程可以尽快地把一个或多个消息发送给目标；而接收进程平时处于阻塞状态，直到有消息发送来为止。如服务器上的打印服务</li>
<li><strong>发送进程和接收进程均不阻塞</strong>——平时，发送进程与接收进程都在忙自己的事情，仅当发生某事使它无法运行时才把自己阻塞起来等待</li>
</ul>
</li>
</ul>
<h2 id="消息缓冲队列通信机制"><a class="markdownIt-Anchor" href="#消息缓冲队列通信机制"></a> 消息缓冲队列通信机制</h2>
<ul>
<li>消息缓冲队列通信机制中的数据结构
<ul>
<li>消息缓冲区——在消息缓冲队列通信方式中，主要利用的数据结构是消息缓冲区。它可描述如下</li>
</ul>
  <figure class="highlight pascal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="keyword">message</span> buffer=<span class="keyword">record</span></span><br><span class="line">    sender; <span class="comment">//发送者进程标识符</span></span><br><span class="line">    size; <span class="comment">//消息长度</span></span><br><span class="line">    text; <span class="comment">//消息正文</span></span><br><span class="line">    next; <span class="comment">//指向下一个消息缓冲区的指针</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
</li>
<li>PCB中有关通信的数据项。在利用消息缓冲队列通信机制时，在设置消息缓冲队列的同时，还应增加用于对消息队列进行操作和实现同步的信号量，并将它们置入进程的PCB中。在PCB中数据项可描述如下  <figure class="highlight pascal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> processcontrol block=<span class="keyword">record</span></span><br><span class="line">       …</span><br><span class="line">       mq;        <span class="comment">//消息队列队首指针</span></span><br><span class="line">       mutex;     <span class="comment">//消息队列互斥信号量</span></span><br><span class="line">       sm;        <span class="comment">//消息队列资源信号量</span></span><br><span class="line">       …</span><br><span class="line">   <span class="keyword">end</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="发送原语"><a class="markdownIt-Anchor" href="#发送原语"></a> 发送原语</h3>
<ul>
<li>发送进程：
<ol>
<li>先在自己的内存空间，设置一<strong>发送区a</strong>；</li>
<li>把待发送的消息正文、发送进程标识符、消息长度等信息填入其中；</li>
<li>调用发送原语，把消息发送给目标(接收)进程</li>
</ol>
</li>
<li>发送原语：首先根据发送区a中所设置的<strong>消息长度</strong>a.size来申请一缓冲区i，接着，把发送区a中的信息复制到缓冲区i中</li>
<li>为了能将i挂在接收进程的消息队列mq上，应先<strong>获得接收进程的内部标识符j</strong>，然后将i挂在j.mq上</li>
<li>由于该<strong>队列</strong>属于<strong>临界资源</strong>， 故在执行insert操作的前后，都要执行wait和signal操作<br />
<img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://gitee.com/zoruasama/Zorua-Pic/raw/master/20200505220125.png" alt="" /></li>
</ul>
<figure class="highlight pascal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//发送原语</span></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">send</span><span class="params">(receiver, a)</span></span></span><br><span class="line"><span class="function">   <span class="title">begin</span></span></span><br><span class="line"><span class="function">      <span class="title">getbuf</span><span class="params">(a.size,i)</span>;</span>         根据a.size申请缓冲区(发送区a)</span><br><span class="line">      i.sender:=a.sender;  将发送区a中信息复制到消息缓冲区中</span><br><span class="line">      i.size:=a.size;</span><br><span class="line">      i.text=a.text;</span><br><span class="line">      i.next:=<span class="number">0</span>;</span><br><span class="line">      getid(PCB <span class="keyword">set</span>, receiver.j);   获得接收进程内部标识符；</span><br><span class="line">      wait(j.mutex);</span><br><span class="line">      insert(j.mq, i);   将消息缓冲区插入消息队列；</span><br><span class="line">      signal(j.mutex);</span><br><span class="line">      signal(j.sm);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="comment">//接收原语</span></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">receive</span><span class="params">(b)</span></span></span><br><span class="line"><span class="function">   <span class="title">begin</span></span></span><br><span class="line"><span class="function">      <span class="title">j</span>:</span>=internal <span class="keyword">name</span>; j为接收进程内部的标识符；</span><br><span class="line">      wait(j.sm);        申请队列资源</span><br><span class="line">      wait(j.mutex);      申请互斥</span><br><span class="line">      remove(j.mq, i);   将消息队列中第一个消息移出；</span><br><span class="line">      signal(j.mutex);</span><br><span class="line">      b.sender:=i.sender; 将消息缓冲区i中信息复制到接收区b;</span><br><span class="line">      b.size:=i.size;</span><br><span class="line">      b.text:=i.text;</span><br><span class="line">   <span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h1 id="线程"><a class="markdownIt-Anchor" href="#线程"></a> 线程</h1>
<h2 id="线程的基本概念"><a class="markdownIt-Anchor" href="#线程的基本概念"></a> 线程的基本概念</h2>
<h3 id="进程的两个基本属性"><a class="markdownIt-Anchor" href="#进程的两个基本属性"></a> 进程的两个基本属性</h3>
<ul>
<li>可<strong>拥有资源</strong>的独立单位
<ul>
<li>给每个进程分配空间，保存进程映像，控制一些资源（文件，I/O设备），有状态、优先级、调度</li>
</ul>
</li>
<li>可独立<strong>调度和分派</strong>的基本单位</li>
<li>进程是一个执行轨迹</li>
<li>以上<strong>两个属性构成进程并发执行</strong>的基础</li>
</ul>
<h3 id="线程的引入"><a class="markdownIt-Anchor" href="#线程的引入"></a> 线程的引入</h3>
<ul>
<li>为使进程能并发执行，系统必须完成的操作：
<ul>
<li>创建进程</li>
<li>撤消进程</li>
<li>进程切换</li>
</ul>
</li>
<li>缺点：时间空间开销大，限制并发度的提高</li>
<li>在操作系统中，进程的引入提高了计算机资源的利用效率。但在进一步提高进程的并发性时，人们发现进程切换开销占的比重越来越大，同时进程间通信的效率也受到限制。</li>
<li>线程的引入正是为了简化进程间的通信，以<strong>小的开销</strong>来提高进程内的<strong>并发程度</strong>从而提高系统吞吐量， 20世纪80年代中期引入<strong>线程</strong>（Threads）</li>
<li>将进程的两个属性分开，作为<strong>调度和分派的基本单位</strong>，不同时作为资源的拥有者，就形成了线程的概念</li>
<li>线程：有时称轻量级进程，进程中的一个运行实体，是一个CPU调度单位，<strong>资源的拥有者还是进程</strong>或称任务</li>
<li>随着多处理机出现，线程可以更好的改善多机系统的性能</li>
</ul>
<h3 id="线程-2"><a class="markdownIt-Anchor" href="#线程-2"></a> 线程</h3>
<ul>
<li>具有执行状态（状态转换）</li>
<li>不运行时保存上下文</li>
<li>有一个执行栈</li>
<li>有一些局部变量的静态存储</li>
<li>可存取所在进程的内存和其他资源</li>
<li>可以创建、撤消另一个线程</li>
</ul>
<h3 id="线程的属性"><a class="markdownIt-Anchor" href="#线程的属性"></a> 线程的属性</h3>
<ul>
<li>轻型实体
<ul>
<li>只拥有必不可少的资源，如：线程状态、寄存器上下文和栈</li>
</ul>
</li>
<li>独立调度和分派的基本单位
<ul>
<li>具有就绪、阻塞和执行三种基本状态</li>
<li>线程的创建、终止时间比进程短</li>
<li>同进程内线程切换时间比进程短，系统开销小</li>
</ul>
</li>
<li>可并发执行
<ul>
<li>同一进程内的线程并发执行</li>
<li>不同进程间的线程并发执行</li>
</ul>
</li>
<li>共享进程资源
<ul>
<li>由于同进程内线程间共享内存和文件资源，可直接进行不通过内核的通信</li>
</ul>
</li>
</ul>
<h3 id="线程的状态"><a class="markdownIt-Anchor" href="#线程的状态"></a> 线程的状态</h3>
<ul>
<li>状态参数：在OS中的每一个线程都可以利用<strong>线程标识符</strong>和一组<strong>状态参数</strong>进行描述。通常有
<ul>
<li><strong>寄存器状态</strong>， 它包括程序计数器PC和堆栈指针中的内容</li>
<li><strong>堆栈</strong>， 在堆栈中通常保存有局部变量和返回地址</li>
<li><strong>优先级</strong>， 描述线程执行的优先程度；</li>
<li><strong>线程专有存储器</strong>， 用于保存线程自己的局部变量拷贝</li>
<li><strong>信号屏蔽</strong>， 即对某些信号加以屏蔽</li>
<li><strong>线程运行状态</strong></li>
</ul>
</li>
<li>如同传统的进程一样，在各线程之间也存在着<strong>共享资源</strong>和<strong>相互合作的制约关系</strong>，致使线程在运行时也具有<strong>间断性</strong>。 相应地，线程在运行时也具有下述三种基本状态
<ul>
<li><strong>执行状态</strong>，表示线程正获得处理机而运行；</li>
<li><strong>就绪状态</strong>， 指线程已具备了各种执行条件，一旦获得CPU便可执行的状态；</li>
<li><strong>阻塞状态</strong>，指线程在执行中因某事件而受阻，处于暂停执行时的状态</li>
</ul>
</li>
</ul>
<h3 id="线程的创建和终止"><a class="markdownIt-Anchor" href="#线程的创建和终止"></a> 线程的创建和终止</h3>
<pre><code>+ 在多线程OS环境下，应用程序在启动时，通常仅有一个线程在执行，该线程被人们称为“**初始化线程**”。它可根据需要再去创建若干个线程
+ 在创建新线程时，需要利用一个**线程创建函数**（或系统调用），并提供相应的参数，如指向线程主程序的入口指针、堆栈的大小，以及用于调度的优先级等。在线程创建函数执行完后，将返回一个**线程标识符**供以后使用
+ 终止线程的方式有两种
    + 一种是在线程完成了自己的工作后**自愿退出**；
    + 另一种是线程在运行中出现错误或由于某种原因而被其它线程**强行终止**
</code></pre>
<h3 id="多线程os中的进程"><a class="markdownIt-Anchor" href="#多线程os中的进程"></a> 多线程OS中的进程</h3>
<ul>
<li>在多线程OS中，进程是作为<strong>拥有系统资源的基本单位</strong>，通常的进程都<strong>包含多个线程</strong>并为它们提供资源，但此时的进程<strong>就不再作为一个执行的实体</strong>。 多线程OS中的进程有以下属性
<ul>
<li>作为系统资源分配的单位</li>
<li>可包括多个线程</li>
<li>进程不是一个可执行的实体</li>
</ul>
</li>
</ul>
<h3 id="线程和进程的关系"><a class="markdownIt-Anchor" href="#线程和进程的关系"></a> 线程和进程的关系</h3>
<ul>
<li>单进程、单线程</li>
<li>单进程、多线程</li>
<li>多进程、一个进程一个线程</li>
<li>多进程、一个进程多个线程<br />
<img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://gitee.com/zoruasama/Zorua-Pic/raw/master/20200505223705.png" alt="" /><br />
<img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://gitee.com/zoruasama/Zorua-Pic/raw/master/20200505223722.png" alt="" /></li>
</ul>
<h3 id="引入线程的好处"><a class="markdownIt-Anchor" href="#引入线程的好处"></a> 引入线程的好处</h3>
<ul>
<li>创建一个新线程花费时间少（结束亦如此）</li>
<li>两个线程的切换花费时间少</li>
<li>（如果机器设有“存储[恢复]所有寄存器”指令，则整个切换过程用几条指令即可完成）</li>
<li>因为同一进程内的线程共享内存和文件，因此它们之间相互通信无须调用内核</li>
<li>适合多处理机系统</li>
</ul>
<hr />
<blockquote>
<p><strong>例子1</strong><br />
LAN（局域网）中的一个文件服务器，在一段时间内需要处理几个文件请求。有效的方法是为每一个请求创建一个线程。<br />
在一个SMP（对称多处理）上：多个线程可以同时在不同的处理器上运行<br />
<strong>例子2</strong><br />
一个线程显示菜单，并读入用户输入；<br />
另一个线程执行用户命令<br />
考虑一个应用：由几个独立部分组成，这几个部分不需要顺序执行，则每个部分可以以线程方式实现<br />
当一个线程因I/O阻塞时，可以切换到同一应用的另一个线程</p>
</blockquote>
<h3 id="线程与进程的比较"><a class="markdownIt-Anchor" href="#线程与进程的比较"></a> 线程与进程的比较</h3>
<ul>
<li>调度：线程作为调度的基本单位，同进程中线程切换不引起进程切换，当不同进程的线程切换才引起进程切换；进程作为拥有资源的基本单位。</li>
<li>并发性：一个进程间的多个线程可并发。</li>
<li>拥有资源：线程仅拥有隶属进程的资源；进程是拥有资源的独立单位。</li>
<li>系统开销：进程大；线程小。</li>
</ul>
<h2 id="线程间的同步和通信"><a class="markdownIt-Anchor" href="#线程间的同步和通信"></a> 线程间的同步和通信</h2>
<h3 id="互斥锁mutex"><a class="markdownIt-Anchor" href="#互斥锁mutex"></a> 互斥锁(mutex)</h3>
<ul>
<li>互斥锁是一种比较简单的、用于实现进程间对<strong>资源互斥访问</strong>的机制。由于操作互斥锁的时间和空间开锁都较低， 因而较适合于高频度使用的关键共享数据和程序段</li>
<li>互斥锁可以有两种状态， 即<strong>开锁</strong>(unlock)和<strong>关锁</strong>(lock)状态。 相应地，可用两条命令(函数)对互斥锁进行操作。其中的关锁lock操作用于将mutex关上，开锁操作unlock则用于打开mutex</li>
</ul>
<h3 id="条件变量-2"><a class="markdownIt-Anchor" href="#条件变量-2"></a> 条件变量</h3>
<ul>
<li>每一个<strong>条件变量</strong>通常都与一个<strong>互斥锁一起使用</strong>，亦即，在创建一个互斥锁时便联系着一个条件变量。单纯的互斥锁用于<strong>短期锁定</strong>，主要是用来保证对临界区的互斥进入。而条件变量则用于线程的<strong>长期等待</strong>， 直至所等待的资源成为可用的</li>
<li>线程首先对mutex执行关锁操作，若成功便进入临界区，然后查找用于描述资源状态的数据结构，以了解资源的情况。 只要发现所需资源R正处于忙碌状态，线程便转为等待状态， 并对mutex执行开锁操作后，等待该资源被释放； 若资源处于空闲状态，表明线程可以使用该资源，于是将该资源设置为忙碌状态，再对mutex执行开锁操作</li>
</ul>
<hr />
<blockquote>
<p><strong>例：使用互斥锁和条件变量实现对资源R的访问</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Lock mutex;</span><br><span class="line">check data structures;</span><br><span class="line">while(resource busy);</span><br><span class="line">     wait(condition variable);</span><br><span class="line">mark resource as busy;</span><br><span class="line">unlock mutex;</span><br><span class="line">Lock mutex;</span><br><span class="line">mark resource as free;</span><br><span class="line">unlock mutex;</span><br><span class="line">wakeup(condition variable);</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="信号量机制-2"><a class="markdownIt-Anchor" href="#信号量机制-2"></a> 信号量机制</h3>
<h4 id="私用信号量private-samephore"><a class="markdownIt-Anchor" href="#私用信号量private-samephore"></a> 私用信号量(private samephore)</h4>
<ul>
<li>线程可利用私用信号量来实现同一进程中各线程之间的同步</li>
<li>调用创建信号量命令来创建一私用信号量</li>
<li>数据结构是<strong>存放在应用程序的地址空间中</strong></li>
<li>私用信号量属于<strong>特定的进程所有</strong>，OS不知道私用信号量的存在</li>
<li>缺点：易丢失空间，私用信号量的占用者异常结束或正常结束，并未释放该信号量所占有空间时，系统将无法使它恢复为0(空)； 也不能将它传送给下一个请求它的线程</li>
</ul>
<h4 id="公用信号量public-semaphore"><a class="markdownIt-Anchor" href="#公用信号量public-semaphore"></a> 公用信号量(public semaphore)</h4>
<ul>
<li>实现不同进程间或不同进程中各线程之间的同步</li>
<li>有一个公开的名字<strong>供所有的进程使用</strong></li>
<li>数据结构是存放在受保护的系统存储区中，由OS为它分配空间并进行管理，故也称为系统信号量</li>
<li>优点：信号量的占有者在结束时未释放该公用信号量，则OS会自动将该信号量空间回收，并通知下一进程。可见，公用信号量是一种<strong>比较安全的同步机制</strong></li>
</ul>
<h2 id="内核支持线程和用户级线程"><a class="markdownIt-Anchor" href="#内核支持线程和用户级线程"></a> 内核支持线程和用户级线程</h2>
<h3 id="内核支持线程kernel-support-threads"><a class="markdownIt-Anchor" href="#内核支持线程kernel-support-threads"></a> 内核支持线程(Kernel-Support Threads)</h3>
<ul>
<li>用户进程和系统进程都是在操作系统内核的支持下运行的，与内核紧密相关</li>
<li>内核支持线程由<strong>操作系统直接支持</strong>，内核在<strong>其空间内</strong>执行线程的创建、调度和管理。</li>
<li>所有线程管理<strong>由核心完成</strong></li>
<li>没有线程库，但对核心线程工具提供API（应用编程接口）</li>
<li><strong>核心维护</strong>进程和线程的上下文</li>
<li>线程之间的<strong>切换需要核心支持</strong></li>
<li>进行调度以<strong>线程</strong>为基础</li>
<li>例子：Windows NT，OS/2</li>
</ul>
<h4 id="核心级线程的优点和缺点"><a class="markdownIt-Anchor" href="#核心级线程的优点和缺点"></a> 核心级线程的优点和缺点</h4>
<ul>
<li>优点:
<ul>
<li>对多处理器，核心可以同时调度同一进程的多个线程</li>
<li>阻塞是在线程一级完成</li>
<li>核心例程是多线程的</li>
</ul>
</li>
<li>缺点：
<ul>
<li>在同一进程内的线程切换调用内核，导致速度下降</li>
</ul>
</li>
</ul>
<h3 id="用户级线程user-level-threads"><a class="markdownIt-Anchor" href="#用户级线程user-level-threads"></a> 用户级线程(User-Level Threads)</h3>
<ul>
<li>用户级线程在内核之上支持，并在用户层通过线程库来实现。线程库提供对线程创建、调度和管理的支持而无需内核支持。</li>
<li>调度<strong>仍然是以进程为单位的</strong></li>
<li>因内核并不知道用户级线程，所以所有线程的创建和调度是在<strong>用户空间内</strong>进行的，无需内核干涉</li>
<li>由于切换的规则远比进程调度和切换的规则简单，因而使线程的切换速度特别快。可见，这种<strong>线程是与内核无关的</strong></li>
</ul>
<h4 id="用户级线程的优点和缺点"><a class="markdownIt-Anchor" href="#用户级线程的优点和缺点"></a> 用户级线程的优点和缺点</h4>
<ul>
<li>优点：
<ul>
<li>线程切换不调用核心</li>
<li>调度是应用程序特定的：可以选择最好的算法</li>
<li>ULT可运行在任何操作系统上（只需要线程库）</li>
</ul>
</li>
<li>缺点：
<ul>
<li>大多数系统调用是阻塞的，若核心阻塞进程，则进程中所有线程将被阻塞</li>
<li><strong>核心只将处理器分配给进程</strong>，同一进程中的两个线程<strong>不能同时运行</strong>于两个处理器上</li>
</ul>
</li>
</ul>
<h2 id="线程控制"><a class="markdownIt-Anchor" href="#线程控制"></a> 线程控制</h2>
<h3 id="内核支持线程的实现"><a class="markdownIt-Anchor" href="#内核支持线程的实现"></a> 内核支持线程的实现</h3>
<ul>
<li>不论是进程还是线程都必须直接或间接地取得内核的支持。由于内核支持线程可以直接利用系统调用为它服务，故线程的控制简单</li>
<li>系统在创建一个<strong>新进程</strong>时，为它分配任务数据区PTDA(Per Task Data Area)，其中包括若干个<strong>线程控制块TCB</strong>空间。在每个TCB中可保存线程标识符、优先级、线程运行的CPU状态等信息</li>
<li>进程在创建一个<strong>线程</strong>时，为它<strong>分配一个TCB</strong>，将有关信息写入该TCB中，并为之分配必要的资源</li>
<li>撤消线程时，也要<strong>回收</strong>该线程所有资源和TCB</li>
<li>其切换也与进程的调度的切换<strong>十分相似</strong>，也分<strong>抢占式与非抢占式两种</strong>。在线程的调度算法上也可以采用<strong>时间片轮转法、优先权法</strong>等<br />
<img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://gitee.com/zoruasama/Zorua-Pic/raw/master/20200505224646.png" alt="" /></li>
</ul>
<h3 id="用户级线程的实现"><a class="markdownIt-Anchor" href="#用户级线程的实现"></a> 用户级线程的实现</h3>
<h4 id="运行时系统runtime-system"><a class="markdownIt-Anchor" href="#运行时系统runtime-system"></a> 运行时系统(Runtime System)</h4>
<ul>
<li>所谓“运行时系统”，实质上是用于<strong>管理和控制线程的函数(过程)的集合</strong>， 其中包括
<ul>
<li>用于创建和撤消线程的函数、 线程同步和通信的函数以及实现线程调度的函数等</li>
<li>这些函数<strong>使用户级线程与内核无关</strong></li>
<li>运行时系统中的所有函数都驻留在用户空间，并作为用户级线程与内核之间的接口</li>
</ul>
</li>
</ul>
<h4 id="内核控制线程"><a class="markdownIt-Anchor" href="#内核控制线程"></a> 内核控制线程</h4>
<ul>
<li>这种线程又称为轻型进程LWP(Light Weight Process)。</li>
<li><strong>每一个进程都可拥有多个LWP</strong>， 同用户级线程一样， 每个LWP都有自己的数据结构(如TCB)，其中包括线程标识符、优先级、 状态， 另外还有栈和局部存储区等</li>
<li>也可以共享进程所拥有的资源。<strong>LWP可通过系统调用来获得内核提供的服务</strong>，这样，当一个用户级线程运行时，<strong>只要将它连接到一个LWP上</strong>，此时它便具有了内核支持线程的所有属性<br />
<img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://gitee.com/zoruasama/Zorua-Pic/raw/master/20200505224824.png" alt="" /></li>
</ul>
<blockquote>
<p>当用户级线程要通信时，须借助于轻型进程LWP，而且每个要通信的用户级线程都需要一个LWP</p>
</blockquote>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/zoruasama/zoruasama.github.io@latest/css/mindmap.css"></div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Zorua</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://zoruasama.gitee.io/2020/05/05/operating_system_1/">https://zoruasama.gitee.io/2020/05/05/operating_system_1/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://zoruasama.gitee.io" target="_blank">Zorua's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a><a class="post-meta__tags" href="/tags/OS/">OS</a></div><div class="post_share"><div class="social-share" data-image="https://gitee.com/zoruasama/Zorua-Pic/raw/master/databasecover.png" data-sites="wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-button button--primary button--animated"> <i class="fa fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="post-qr-code__img" src="/img/%E5%BE%AE%E4%BF%A1.png" alt="微信"/><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="post-qr-code__img" src="/img/%E6%94%AF%E4%BB%98%E5%AE%9D.png" alt="支付寶"/><div class="post-qr-code__desc">支付寶</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2020/05/12/database_2/"><img class="prev_cover" data-src="https://gitee.com/zoruasama/Zorua-Pic/raw/master/databasecover.png" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">数据库原理 | 3. 关系数据库标准语言SQL</div></div></a></div><div class="next-post pull_right"><a href="/2020/05/02/network_2/"><img class="next_cover" data-src="https://gitee.com/zoruasama/Zorua-Pic/raw/master/20200419231702.png" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">计算机网络 | 3. 数据链路层</div></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-fw fa-thumbs-up" aria-hidden="true"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2020/04/29/operating_system_0/" title="操作系统 | 1. 操作系统引论"><img class="relatedPosts_cover" data-src="https://gitee.com/zoruasama/Zorua-Pic/raw/master/20200429125019.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-04-29</div><div class="relatedPosts_title">操作系统 | 1. 操作系统引论</div></div></a></div><div class="relatedPosts_item"><a href="/2020/03/29/Linux_0/" title="Linux入门 | 1. Linux的介绍"><img class="relatedPosts_cover" data-src="https://gitee.com/zoruasama/Zorua-Pic/raw/master/linux.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-03-29</div><div class="relatedPosts_title">Linux入门 | 1. Linux的介绍</div></div></a></div><div class="relatedPosts_item"><a href="/2020/04/14/Linux_1/" title="Linux入门 | 2. 终端介绍"><img class="relatedPosts_cover" data-src="https://gitee.com/zoruasama/Zorua-Pic/raw/master/linux.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-04-14</div><div class="relatedPosts_title">Linux入门 | 2. 终端介绍</div></div></a></div><div class="relatedPosts_item"><a href="/2020/08/27/Linux_2/" title="Linux入门 | 3.常用命令"><img class="relatedPosts_cover" data-src="https://gitee.com/zoruasama/Zorua-Pic/raw/master/linux.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-08-27</div><div class="relatedPosts_title">Linux入门 | 3.常用命令</div></div></a></div><div class="relatedPosts_item"><a href="/2020/07/22/windows_0/" title="Windows | 应用程序的Zorua有机分类使用管理办法"><img class="relatedPosts_cover" data-src="https://gitee.com/zoruasama/Zorua-Pic/raw/master/20200722191902.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-07-22</div><div class="relatedPosts_title">Windows | 应用程序的Zorua有机分类使用管理办法</div></div></a></div></div><div class="clear_both"></div></div><hr><div id="post-comment"><div class="comment_headling"><i class="fa fa-comments fa-fw" aria-hidden="true"></i><span> 评论</span></div><div class="vcomment" id="vcomment"></div><script src="//unpkg.com/valine@latest/dist/Valine.min.js"></script><script>var requestSetting = function (from,set) {
  var from = from
  var setting = set.split(',').filter(function(item){
  return from.indexOf(item) > -1
  });
  setting = setting.length == 0 ? from :setting;
  return setting
}

var guestInfo = requestSetting(['nick','mail','link'],'nick,mail')
var requiredFields = requestSetting(['nick','mail','link'],'nick,mail')

window.valine = new Valine({
  el:'#vcomment',
  appId: 'YVFPT1pFRjpG5oM88rpDgyj7-MdYXbMMI',
  appKey: 'pry5uB2QzPFBPeMcz9MzkeIz',
  notify: true,
  verify: true,
  placeholder: '回复时留下邮箱便于收到回复提醒~~~\n在昵称中填入QQ号，会自动获取昵称和QQ头像哦。\n截图并粘贴，可以生成对应MD语句以上传图片。',
  avatar: 'monsterid',
  meta: guestInfo,
  pageSize: '10',
  lang: 'zh-cn',
  recordIP: false,
  serverURLs: '',
  emojiCDN: 'https://valinecdn.bili33.top/',
  emojiMaps: {
      "bilibiliHotKey1": "bilibiliHotKey/1.jpg",
      "bilibiliHotKey2": "bilibiliHotKey/10.jpg",
      "bilibiliHotKey3": "bilibiliHotKey/11.jpg",
      "bilibiliHotKey4": "bilibiliHotKey/12.jpg",
      "bilibiliHotKey5": "bilibiliHotKey/13.jpg",
      "bilibiliHotKey6": "bilibiliHotKey/14.jpg",
      "bilibiliHotKey7": "bilibiliHotKey/15.jpg",
      "bilibiliHotKey8": "bilibiliHotKey/16.jpg",
      "bilibiliHotKey9": "bilibiliHotKey/17.jpg",
      "bilibiliHotKey10": "bilibiliHotKey/18.jpg",
      "bilibiliHotKey11": "bilibiliHotKey/19.jpg",
      "bilibiliHotKey12": "bilibiliHotKey/2.jpg",
      "bilibiliHotKey13": "bilibiliHotKey/20.jpg",
      "bilibiliHotKey14": "bilibiliHotKey/21.jpg",
      "bilibiliHotKey15": "bilibiliHotKey/22.jpg",
      "bilibiliHotKey16": "bilibiliHotKey/23.jpg",
      "bilibiliHotKey17": "bilibiliHotKey/24.jpg",
      "bilibiliHotKey18": "bilibiliHotKey/25.jpg",
      "bilibiliHotKey19": "bilibiliHotKey/26.jpg",
      "bilibiliHotKey20": "bilibiliHotKey/27.jpg",
      "bilibiliHotKey21": "bilibiliHotKey/28.jpg",
      "bilibiliHotKey22": "bilibiliHotKey/29.jpg",
      "bilibiliHotKey23": "bilibiliHotKey/3.jpg",
      "bilibiliHotKey24": "bilibiliHotKey/30.jpg",
      "bilibiliHotKey25": "bilibiliHotKey/31.jpg",
      "bilibiliHotKey26": "bilibiliHotKey/32.jpg",
      "bilibiliHotKey27": "bilibiliHotKey/4.jpg",
      "bilibiliHotKey28": "bilibiliHotKey/5.jpg",
      "bilibiliHotKey29": "bilibiliHotKey/6.jpg",
      "bilibiliHotKey30": "bilibiliHotKey/7.jpg",
      "bilibiliHotKey31": "bilibiliHotKey/8.jpg",
      "bilibiliHotKey32": "bilibiliHotKey/9.jpg",
      "alu2": "alu/不出所料.png",
      "alu3": "alu/不说话.png",
      "alu4": "alu/不高兴.png",
      "alu5": "alu/中刀.png",
      "alu6": "alu/中指.png",
      "alu7": "alu/中枪.png",
      "alu8": "alu/亲亲.png",
      "alu9": "alu/便便.png",
      "alu10": "alu/内伤.png",
      "alu11": "alu/击掌.png",
      "alu12": "alu/口水.png",
      "alu13": "alu/吐.png",
      "alu14": "alu/吐舌.png",
      "alu15": "alu/吐血倒地.png",
      "alu16": "alu/呲牙.png",
      "alu17": "alu/咽气.png",
      "alu18": "alu/哭泣.png",
      "alu19": "alu/喜极而泣.png",
      "alu20": "alu/喷水.png",
      "alu21": "alu/喷血.png",
      "alu22": "alu/坐等.png",
      "alu23": "alu/害羞.png",
      "alu24": "alu/小眼睛.png",
      "alu25": "alu/尴尬.png",
      "alu26": "alu/得意.png",
      "alu27": "alu/惊喜.png",
      "alu28": "alu/想一想.png",
      "alu29": "alu/愤怒.png",
      "alu30": "alu/扇耳光.png",
      "alu31": "alu/投降.png",
      "alu32": "alu/抠鼻.png",
      "alu33": "alu/抽烟.png",
      "alu34": "alu/无奈.png",
      "alu35": "alu/无所谓.png",
      "alu36": "alu/无语.png",
      "alu37": "alu/暗地观察.png",
      "alu38": "alu/期待.png",
      "alu39": "alu/欢呼.png",
      "alu40": "alu/汗.png",
      "alu41": "alu/深思.png",
      "alu42": "alu/狂汗.png",
      "alu43": "alu/献花.png",
      "alu44": "alu/献黄瓜.png",
      "alu45": "alu/皱眉.png",
      "alu46": "alu/看不见.png",
      "alu47": "alu/看热闹.png",
      "alu48": "alu/瞅你.png",
      "alu49": "alu/肿包.png",
      "alu50": "alu/脸红.png",
      "alu51": "alu/蜡烛.png",
      "alu52": "alu/装大款.png",
      "alu53": "alu/观察.png",
      "alu54": "alu/赞一个.png",
      "alu55": "alu/邪恶.png",
      "alu56": "alu/锁眉.png",
      "alu57": "alu/长草.png",
      "alu58": "alu/阴暗.png",
      "alu59": "alu/高兴.png",
      "alu60": "alu/黑线.png",
      "alu61": "alu/鼓掌.png",
      "bilibilitv2": "bilibilitv/[tv_doge].png",
      "bilibilitv3": "bilibilitv/[tv_亲亲].png",
      "bilibilitv4": "bilibilitv/[tv_偷笑].png",
      "bilibilitv5": "bilibilitv/[tv_再见].png",
      "bilibilitv6": "bilibilitv/[tv_冷漠].png",
      "bilibilitv7": "bilibilitv/[tv_发怒].png",
      "bilibilitv8": "bilibilitv/[tv_发财].png",
      "bilibilitv9": "bilibilitv/[tv_可爱].png",
      "bilibilitv10": "bilibilitv/[tv_吐血].png",
      "bilibilitv11": "bilibilitv/[tv_呆].png",
      "bilibilitv12": "bilibilitv/[tv_呕吐].png",
      "bilibilitv13": "bilibilitv/[tv_困].png",
      "bilibilitv14": "bilibilitv/[tv_坏笑].png",
      "bilibilitv15": "bilibilitv/[tv_大佬].png",
      "bilibilitv16": "bilibilitv/[tv_大哭].png",
      "bilibilitv17": "bilibilitv/[tv_委屈].png",
      "bilibilitv18": "bilibilitv/[tv_害羞].png",
      "bilibilitv19": "bilibilitv/[tv_尴尬].png",
      "bilibilitv20": "bilibilitv/[tv_微笑].png",
      "bilibilitv21": "bilibilitv/[tv_思考].png",
      "bilibilitv22": "bilibilitv/[tv_惊吓].png",
      "bilibilitv23": "bilibilitv/[tv_打脸].png",
      "bilibilitv24": "bilibilitv/[tv_抓狂].png",
      "bilibilitv25": "bilibilitv/[tv_抠鼻].png",
      "bilibilitv26": "bilibilitv/[tv_斜眼笑].png",
      "bilibilitv27": "bilibilitv/[tv_无奈].png",
      "bilibilitv28": "bilibilitv/[tv_晕].png",
      "bilibilitv29": "bilibilitv/[tv_流汗].png",
      "bilibilitv30": "bilibilitv/[tv_流泪].png",
      "bilibilitv31": "bilibilitv/[tv_流鼻血].png",
      "bilibilitv32": "bilibilitv/[tv_点赞].png",
      "bilibilitv33": "bilibilitv/[tv_生气].png",
      "bilibilitv34": "bilibilitv/[tv_生病].png",
      "bilibilitv35": "bilibilitv/[tv_疑问].png",
      "bilibilitv36": "bilibilitv/[tv_白眼].png",
      "bilibilitv37": "bilibilitv/[tv_皱眉].png",
      "bilibilitv38": "bilibilitv/[tv_目瞪口呆].png",
      "bilibilitv39": "bilibilitv/[tv_睡着].png",
      "bilibilitv40": "bilibilitv/[tv_笑哭].png",
      "bilibilitv41": "bilibilitv/[tv_腼腆].png",
      "bilibilitv42": "bilibilitv/[tv_色].png",
      "bilibilitv43": "bilibilitv/[tv_调侃].png",
      "bilibilitv44": "bilibilitv/[tv_调皮].png",
      "bilibilitv45": "bilibilitv/[tv_鄙视].png",
      "bilibilitv46": "bilibilitv/[tv_闭嘴].png",
      "bilibilitv47": "bilibilitv/[tv_难过].png",
      "bilibilitv48": "bilibilitv/[tv_馋].png",
      "bilibilitv49": "bilibilitv/[tv_鬼脸].png",
      "bilibilitv50": "bilibilitv/[tv_黑人问号].png",
      "bilibilitv51": "bilibilitv/[tv_鼓掌].png",
      "bilibili22332": "bilibili2233/[2233娘_卖萌].png",
      "bilibili22333": "bilibili2233/[2233娘_吃惊].png",
      "bilibili22334": "bilibili2233/[2233娘_吐魂].png",
      "bilibili22335": "bilibili2233/[2233娘_喝水].png",
      "bilibili22336": "bilibili2233/[2233娘_困惑].png",
      "bilibili22337": "bilibili2233/[2233娘_大哭].png",
      "bilibili22338": "bilibili2233/[2233娘_大笑].png",
      "bilibili22339": "bilibili2233/[2233娘_委屈].png",
      "bilibili223310": "bilibili2233/[2233娘_怒].png",
      "bilibili223311": "bilibili2233/[2233娘_无言].png",
      "bilibili223312": "bilibili2233/[2233娘_汗].png",
      "bilibili223313": "bilibili2233/[2233娘_疑问].png",
      "bilibili223314": "bilibili2233/[2233娘_第一].png",
      "bilibili223315": "bilibili2233/[2233娘_耶].png",
      "bilibili223316": "bilibili2233/[2233娘_郁闷].png",
      "weibo2": "weibo/d_aoteman.png",
      "weibo3": "weibo/d_baibai.png",
      "weibo4": "weibo/d_baobao.png",
      "weibo5": "weibo/d_beishang.png",
      "weibo6": "weibo/d_bingbujiandan.png",
      "weibo7": "weibo/d_bishi.png",
      "weibo8": "weibo/d_bizui.png",
      "weibo9": "weibo/d_chanzui.png",
      "weibo10": "weibo/d_chigua.png",
      "weibo11": "weibo/d_chijing.png",
      "weibo12": "weibo/d_dahaqi.png",
      "weibo13": "weibo/d_dalian.png",
      "weibo14": "weibo/d_ding.png",
      "weibo15": "weibo/d_doge.png",
      "weibo16": "weibo/d_erha.png",
      "weibo17": "weibo/d_feijie.png",
      "weibo18": "weibo/d_feizao.png",
      "weibo19": "weibo/d_ganmao.png",
      "weibo20": "weibo/d_guile.png",
      "weibo21": "weibo/d_guzhang.png",
      "weibo22": "weibo/d_haha.png",
      "weibo23": "weibo/d_haixiu.png",
      "weibo24": "weibo/d_han.png",
      "weibo25": "weibo/d_hehe.png",
      "weibo26": "weibo/d_heiheihei.png",
      "weibo27": "weibo/d_heixian.png",
      "weibo28": "weibo/d_heng.png",
      "weibo29": "weibo/d_huaixiao.png",
      "weibo30": "weibo/d_huaxin.png",
      "weibo31": "weibo/d_jiyan.png",
      "weibo32": "weibo/d_keai.png",
      "weibo33": "weibo/d_kelian.png",
      "weibo34": "weibo/d_ku.png",
      "weibo35": "weibo/d_kulou.png",
      "weibo36": "weibo/d_kun.png",
      "weibo37": "weibo/d_landelini.png",
      "weibo38": "weibo/d_lang.png",
      "weibo39": "weibo/d_lei.png",
      "weibo40": "weibo/d_miao.png",
      "weibo41": "weibo/d_nanhaier.png",
      "weibo42": "weibo/d_nu.png",
      "weibo43": "weibo/d_numa.png",
      "weibo44": "weibo/d_nvhaier.png",
      "weibo45": "weibo/d_qian.png",
      "weibo46": "weibo/d_qinqin.png",
      "weibo47": "weibo/d_shayan.png",
      "weibo48": "weibo/d_shengbing.png",
      "weibo49": "weibo/d_shenshou.png",
      "weibo50": "weibo/d_shiwang.png",
      "weibo51": "weibo/d_shuai.png",
      "weibo52": "weibo/d_shuijiao.png",
      "weibo53": "weibo/d_sikao.png",
      "weibo54": "weibo/d_taikaixin.png",
      "weibo55": "weibo/d_tanshou.png",
      "weibo56": "weibo/d_tian.png",
      "weibo57": "weibo/d_touxiao.png",
      "weibo58": "weibo/d_tu.png",
      "weibo59": "weibo/d_tuzi.png",
      "weibo60": "weibo/d_wabishi.png",
      "weibo61": "weibo/d_weiqu.png",
      "weibo62": "weibo/d_wu.png",
      "weibo63": "weibo/d_xiaoku.png",
      "weibo64": "weibo/d_xingxingyan.png",
      "weibo65": "weibo/d_xiongmao.png",
      "weibo66": "weibo/d_xixi.png",
      "weibo67": "weibo/d_xu.png",
      "weibo68": "weibo/d_yinxian.png",
      "weibo69": "weibo/d_yiwen.png",
      "weibo70": "weibo/d_youhengheng.png",
      "weibo71": "weibo/d_yun.png",
      "weibo72": "weibo/d_yunbei.png",
      "weibo73": "weibo/d_zhuakuang.png",
      "weibo74": "weibo/d_zhutou.png",
      "weibo75": "weibo/d_zuiyou.png",
      "weibo76": "weibo/emoji_0x1f31f.png",
      "weibo77": "weibo/emoji_0x1f349.png",
      "weibo78": "weibo/emoji_0x1f357.png",
      "weibo79": "weibo/emoji_0x1f384.png",
      "weibo80": "weibo/emoji_0x1f44f.png",
      "weibo81": "weibo/emoji_0x1f47b.png",
      "weibo82": "weibo/emoji_0x1f47f.png",
      "weibo83": "weibo/emoji_0x1f48a.png",
      "weibo84": "weibo/emoji_0x1f4a3.png",
      "weibo85": "weibo/emoji_0x1f4a9.png",
      "weibo86": "weibo/emoji_0x1f631.png",
      "weibo87": "weibo/emoji_0x1f643.png",
      "weibo88": "weibo/emoji_0x1f645.png",
      "weibo89": "weibo/emoji_0x1f648.png",
      "weibo90": "weibo/emoji_0x1f649.png",
      "weibo91": "weibo/emoji_0x1f64a.png",
      "weibo92": "weibo/emoji_0x1f64b.png",
      "weibo93": "weibo/emoji_0x1f64f.png",
      "weibo94": "weibo/emoji_0x1f913.png",
      "weibo95": "weibo/emoji_0x1f917.png",
      "weibo96": "weibo/emoji_0x26a1.png",
      "weibo97": "weibo/h_buyao.png",
      "weibo98": "weibo/h_good.png",
      "weibo99": "weibo/h_haha.png",
      "weibo100": "weibo/h_jiayou.png",
      "weibo101": "weibo/h_lai.png",
      "weibo102": "weibo/h_ok.png",
      "weibo103": "weibo/h_quantou.png",
      "weibo104": "weibo/h_ruo.png",
      "weibo105": "weibo/h_woshou.png",
      "weibo106": "weibo/h_ye.png",
      "weibo107": "weibo/h_zan.png",
      "weibo108": "weibo/h_zuoyi.png",
      "Little-Bad2": "Little-Bad/一群坏坏.jpg",
      "Little-Bad3": "Little-Bad/中坏坏.jpg",
      "Little-Bad4": "Little-Bad/发火的坏坏.jpg",
      "Little-Bad5": "Little-Bad/坏坏坏.jpg",
      "Little-Bad6": "Little-Bad/大坏坏.jpg",
      "Little-Bad7": "Little-Bad/天使一般的坏坏.jpg",
      "Little-Bad8": "Little-Bad/害羞坏.jpg",
      "Little-Bad9": "Little-Bad/小坏蛋.jpg",
      "Little-Bad10": "Little-Bad/我们一起做坏坏的事.jpg",
      "Little-Bad11": "Little-Bad/敲板子的坏坏.gif",
      "Little-Bad12": "Little-Bad/比地球还大的坏坏.jpg",
      "Little-Bad13": "Little-Bad/流泪的坏坏.jpg",
      "Little-Bad14": "Little-Bad/热炸的坏坏.jpg"
  },
  enableQQ: true,
  requiredFields: requiredFields
});</script></div></article></main><footer id="footer" style="background-image: url(https://gitee.com/zoruasama/Zorua-Pic/raw/master/20200429125104.png)" data-type="photo"><div id="footer-wrap"><div class="copyright">&copy;2020 By Zorua</div><div class="framework-info"><span>Powered BY </span><a href="https://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div><div class="footer_custom_text">这是我的底线。</div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">繁</a><i class="darkmode far fa-moon" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><a id="to_comment" href="#post-comment" title="直达评论"><i class="scroll_to_comment fa fa-comments">  </i></a><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" target="_blank" rel="noopener" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.css"><script>$(function () {
  $('span.katex-display').wrap('<div class="katex-wrap"></div>')
})</script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script id="canvas_nest" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="/js/third-party/canvas-nest.js"></script><script src="/js/third-party/activate-power-mode.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
document.body.addEventListener('input', POWERMODE);
</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@v3.0.0/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script><script src="/js/search/local-search.js"></script><script>if (document.getElementsByClassName('mermaid').length) {
  loadScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js',function () {
    mermaid.initialize({
      theme: 'default',
  })
})
}</script><script src="/js/zorua.js"></script><script src="/js/hideCategory.js"></script></body></html>